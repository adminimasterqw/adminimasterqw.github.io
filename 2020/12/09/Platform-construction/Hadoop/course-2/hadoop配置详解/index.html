<!-- build time:Wed Dec 09 2020 20:51:55 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Andrésen" href="https://methiony.work/rss.xml"><link rel="alternate" type="application/atom+xml" title="Andrésen" href="https://methiony.work/atom.xml"><link rel="alternate" type="application/json" title="Andrésen" href="https://methiony.work/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.4"><link rel="canonical" href="https://methiony.work/2020/12/09/Platform-construction/Hadoop/course-2/hadoop%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"><title>hadoop配置详解 - Hadoop基础知识 - Hadoop - 大数据平台搭建 | Methiony Shoka = Andrésen</title><meta name="generator" content="Hexo 5.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">hadoop配置详解</h1><div class="meta"><span class="item" title="创建时间：2020-12-09 17:15:40"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2020-12-09T17:15:40+08:00">2020-12-09</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>160k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>2:26</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Methiony Shoka</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipeubcbajj20zk0m8h1h.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicit31ffoj20zk0m8naf.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicitspjpbj20zk0m81ky.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipeyhsblkj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicitcxhpij20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclip4jbpj20zk0m87cv.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Platform-construction/" itemprop="item" rel="index" title="分类于 大数据平台搭建"><span itemprop="name">大数据平台搭建</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Platform-construction/Hadoop/" itemprop="item" rel="index" title="分类于 Hadoop"><span itemprop="name">Hadoop</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Platform-construction/Hadoop/course-2/" itemprop="item" rel="index" title="分类于 Hadoop基础知识"><span itemprop="name">Hadoop基础知识</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://methiony.work/2020/12/09/Platform-construction/Hadoop/course-2/hadoop%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Andrésen"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Andrésen"></span><div class="body md" itemprop="articleBody"><div class="note info"><p>以下为个人学习笔记<br>官方文档：<br><span class="exturl" data-url="aHR0cHM6Ly9oYWRvb3AuYXBhY2hlLm9yZy9kb2NzL3IyLjYuNS9oYWRvb3AtcHJvamVjdC1kaXN0L2hhZG9vcC1oZGZzL0hERlNIaWdoQXZhaWxhYmlsaXR5V2l0aFFKTS5odG1sI1B1cnBvc2U=">https://hadoop.apache.org/docs/r2.6.5/hadoop-project-dist/hadoop-hdfs/HDFSHighAvailabilityWithQJM.html#Purpose</span></p></div><h4 id="配置细节"><a class="anchor" href="#配置细节">#</a> 配置细节</h4><p>要配置 HA NameNodes, 你必须在你的 <strong>hdfs-site.xml</strong> 配置文件中配置一些选项.</p><p><strong>dfs.nameservices</strong> - 此服务的新逻辑名称</p><pre><code>&lt;property&gt;
  &lt;name&gt;dfs.nameservices&lt;/name&gt;
  &lt;value&gt;mycluster&lt;/value&gt;
&lt;/property&gt;
</code></pre><p><strong>Note:</strong> If you are also using HDFS Federation, this configuration setting should also include the list of other nameservices, HA or otherwise, as a comma-separated list.</p><p><strong>dfs.ha.namenodes.[nameservice ID]</strong> - unique identifiers for each NameNode in the nameservice</p><pre><code>&lt;property&gt;
  &lt;name&gt;dfs.ha.namenodes.mycluster&lt;/name&gt;
  &lt;value&gt;nn1,nn2&lt;/value&gt;
&lt;/property&gt;
</code></pre><p><strong>Note:</strong> Currently, only a maximum of two NameNodes may be configured per nameservice.</p><p><strong>dfs.namenode.rpc-address.[nameservice ID].[name node ID]</strong> - the fully-qualified RPC address for each NameNode to listen on</p><p>For both of the previously-configured NameNode IDs, set the full address and IPC port of the NameNode processs. Note that this results in two separate configuration options. For example:</p><pre><code>  &lt;name&gt;dfs.namenode.rpc-address.mycluster.nn1&lt;/name&gt;
  &lt;value&gt;machine1.example.com:8020&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;dfs.namenode.rpc-address.mycluster.nn2&lt;/name&gt;
  &lt;value&gt;machine2.example.com:8020&lt;/value&gt;
&lt;/property&gt;
</code></pre><p><strong>Note:</strong> You may similarly configure the &quot;<strong>servicerpc-address</strong>&quot; setting if you so desire.</p><p><strong>dfs.namenode.http-address.[nameservice ID].[name node ID]</strong> - the fully-qualified HTTP address for each NameNode to listen on</p><p>Similarly to <em>rpc-address</em> above, set the addresses for both NameNodes' HTTP servers to listen on. For example:</p><pre><code>&lt;property&gt;
  &lt;name&gt;dfs.namenode.http-address.mycluster.nn1&lt;/name&gt;
  &lt;value&gt;machine1.example.com:50070&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;dfs.namenode.http-address.mycluster.nn2&lt;/name&gt;
  &lt;value&gt;machine2.example.com:50070&lt;/value&gt;
&lt;/property&gt;
</code></pre><p><strong>Note:</strong> If you have Hadoop's security features enabled, you should also set the <em>https-address</em> similarly for each NameNode.</p><ul><li><p>dfs.namenode.shared.edits.dir</p><p>- the URI which identifies the group of JNs where the NameNodes will write/read edits</p><p>This is where one configures the addresses of the JournalNodes which provide the shared edits storage, written to by the Active nameNode and read by the Standby NameNode to stay up-to-date with all the file system changes the Active NameNode makes. Though you must specify several JournalNode addresses, <strong>you should only configure one of these URIs.</strong> The URI should be of the form: &quot;qjournal://<em>host1:port1</em>;<em>host2:port2</em>;<em>host3:port3</em>/<em>journalId</em>&quot;. The Journal ID is a unique identifier for this nameservice, which allows a single set of JournalNodes to provide storage for multiple federated namesystems. Though not a requirement, it's a good idea to reuse the nameservice ID for the journal identifier.</p><p>For example, if the JournalNodes for this cluster were running on the machines &quot;<span class="exturl" data-url="aHR0cDovL25vZGUxLmV4YW1wbGUuY29t">node1.example.com</span>&quot;, &quot;<span class="exturl" data-url="aHR0cDovL25vZGUyLmV4YW1wbGUuY29t">node2.example.com</span>&quot;, and &quot;<span class="exturl" data-url="aHR0cDovL25vZGUzLmV4YW1wbGUuY29t">node3.example.com</span>&quot; and the nameservice ID were &quot;mycluster&quot;, you would use the following as the value for this setting (the default port for the JournalNode is 8485):</p><pre><code>&lt;property&gt;
  &lt;name&gt;dfs.namenode.shared.edits.dir&lt;/name&gt;
  &lt;value&gt;qjournal://node1.example.com:8485;node2.example.com:8485;node3.example.com:8485/mycluster&lt;/value&gt;
&lt;/property&gt;
</code></pre></li><li><p>dfs.client.failover.proxy.provider.[nameservice ID]</p><p>- the Java class that HDFS clients use to contact the Active NameNode</p><p>Configure the name of the Java class which will be used by the DFS Client to determine which NameNode is the current Active, and therefore which NameNode is currently serving client requests. The only implementation which currently ships with Hadoop is the <strong>ConfiguredFailoverProxyProvider</strong>, so use this unless you are using a custom one. For example:</p><pre><code>&lt;property&gt;
  &lt;name&gt;dfs.client.failover.proxy.provider.mycluster&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&lt;/value&gt;
&lt;/property&gt;
</code></pre></li></ul><p><strong>dfs.ha.fencing.methods</strong> - a list of scripts or Java classes which will be used to fence the Active NameNode during a failover</p><p>It is desirable for correctness of the system that only one NameNode be in the Active state at any given time. <strong>Importantly, when using the Quorum Journal Manager, only one NameNode will ever be allowed to write to the JournalNodes, so there is no potential for corrupting the file system metadata from a split-brain scenario.</strong> However, when a failover occurs, it is still possible that the previous Active NameNode could serve read requests to clients, which may be out of date until that NameNode shuts down when trying to write to the JournalNodes. For this reason, it is still desirable to configure some fencing methods even when using the Quorum Journal Manager. However, to improve the availability of the system in the event the fencing mechanisms fail, it is advisable to configure a fencing method which is guaranteed to return success as the last fencing method in the list. Note that if you choose to use no actual fencing methods, you still must configure something for this setting, for example &quot; <code>shell(/bin/true)</code> &quot;.</p><p>The fencing methods used during a failover are configured as a carriage-return-separated list, which will be attempted in order until one indicates that fencing has succeeded. There are two methods which ship with Hadoop: <em>shell</em> and <em>sshfence</em>. For information on implementing your own custom fencing method, see the <em>org.apache.hadoop.ha.NodeFencer</em> class.</p><ul><li><p>sshfence</p><p>- SSH to the Active NameNode and kill the process</p><p>The <em>sshfence</em> option SSHes to the target node and uses <em>fuser</em> to kill the process listening on the service's TCP port. In order for this fencing option to work, it must be able to SSH to the target node without providing a passphrase. Thus, one must also configure the <strong>dfs.ha.fencing.ssh.private-key-files</strong> option, which is a comma-separated list of SSH private key files. For example:</p><pre><code>&lt;property&gt;
  &lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt;
  &lt;value&gt;sshfence&lt;/value&gt;
&lt;/property&gt;

&lt;property&gt;
  &lt;name&gt;dfs.ha.fencing.ssh.private-key-files&lt;/name&gt;
  &lt;value&gt;/home/exampleuser/.ssh/id_rsa&lt;/value&gt;
&lt;/property&gt;
</code></pre><p>Optionally, one may configure a non-standard username or port to perform the SSH. One may also configure a timeout, in milliseconds, for the SSH, after which this fencing method will be considered to have failed. It may be configured like so:</p><pre><code>&lt;property&gt;
  &lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt;
  &lt;value&gt;sshfence([[username][:port]])&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;dfs.ha.fencing.ssh.connect-timeout&lt;/name&gt;
  &lt;value&gt;30000&lt;/value&gt;
&lt;/property&gt;
</code></pre></li></ul><p><strong>shell</strong> - run an arbitrary shell command to fence the Active NameNode</p><p>The <em>shell</em> fencing method runs an arbitrary shell command. It may be configured like so:</p><pre><code>&lt;property&gt;
  &lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt;
  &lt;value&gt;shell(/path/to/my/script.sh arg1 arg2 ...)&lt;/value&gt;
&lt;/property&gt;
</code></pre><p>The string between '(' and ')' is passed directly to a bash shell and may not include any closing parentheses.</p><p>The shell command will be run with an environment set up to contain all of the current Hadoop configuration variables, with the '_' character replacing any '.' characters in the configuration keys. The configuration used has already had any namenode-specific configurations promoted to their generic forms -- for example <strong>dfs_namenode_rpc-address</strong> will contain the RPC address of the target node, even though the configuration may specify that variable as <strong>dfs.namenode.rpc-address.ns1.nn1</strong>.</p><p>These environment variables may also be used as substitutions in the shell command itself. For example:</p><pre><code>&lt;property&gt;
  &lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt;
  &lt;value&gt;shell(/path/to/my/script.sh --nameservice=$target_nameserviceid $target_host:$target_port)&lt;/value&gt;
&lt;/property&gt;
</code></pre><p>If the shell command returns an exit code of 0, the fencing is determined to be successful. If it returns any other exit code, the fencing was not successful and the next fencing method in the list will be attempted.</p><p><strong>Note:</strong> This fencing method does not implement any timeout. If timeouts are necessary, they should be implemented in the shell script itself (eg by forking a subshell to kill its parent in some number of seconds).</p><p><strong>fs.defaultFS</strong> - the default path prefix used by the Hadoop FS client when none is given</p><p>Optionally, you may now configure the default path for Hadoop clients to use the new HA-enabled logical URI. If you used &quot;mycluster&quot; as the nameservice ID earlier, this will be the value of the authority portion of all of your HDFS paths. This may be configured like so, in your <strong>core-site.xml</strong> file:</p><pre><code>&lt;property&gt;
  &lt;name&gt;fs.defaultFS&lt;/name&gt;
  &lt;value&gt;hdfs://mycluster&lt;/value&gt;
&lt;/property&gt;
</code></pre><p><strong>dfs.journalnode.edits.dir</strong> - the path where the JournalNode daemon will store its local state</p><p>This is the absolute path on the JournalNode machines where the edits and other local state used by the JNs will be stored. You may only use a single path for this configuration. Redundancy for this data is provided by running multiple separate JournalNodes, or by configuring this directory on a locally-attached RAID array. For example:</p><pre><code>&lt;property&gt;
  &lt;name&gt;dfs.journalnode.edits.dir&lt;/name&gt;
  &lt;value&gt;/path/to/journal/node/local/data&lt;/value&gt;
&lt;/property&gt;
</code></pre><p>Others</p><p>hdfs-site.xml</p><table><thead><tr><th>name</th><th>value</th><th>description</th></tr></thead><tbody><tr><td>hadoop.hdfs.configuration.version</td><td>1</td><td>version of this configuration file</td></tr><tr><td>dfs.namenode.logging.level</td><td>info</td><td>The logging level for dfs namenode. Other values are &quot;dir&quot; (trace namespace mutations), &quot;block&quot; (trace block under/over replications and block creations/deletions), or &quot;all&quot;.</td></tr><tr><td>dfs.namenode.rpc-address</td><td></td><td>RPC address that handles all clients requests. In the case of HA/Federation where multiple namenodes exist, the name service id is added to the name e.g. dfs.namenode.rpc-address.ns1 dfs.namenode.rpc-address.EXAMPLENAMESERVICE The value of this property will take the form of nn-host1:rpc-port.</td></tr><tr><td>dfs.namenode.rpc-bind-host</td><td></td><td>The actual address the RPC server will bind to. If this optional address is set, it overrides only the hostname portion of dfs.namenode.rpc-address. It can also be specified per name node or name service for HA/Federation. This is useful for making the name node listen on all interfaces by setting it to 0.0.0.0.</td></tr><tr><td>dfs.namenode.servicerpc-address</td><td></td><td>RPC address for HDFS Services communication. BackupNode, Datanodes and all other services should be connecting to this address if it is configured. In the case of HA/Federation where multiple namenodes exist, the name service id is added to the name e.g. dfs.namenode.servicerpc-address.ns1 dfs.namenode.rpc-address.EXAMPLENAMESERVICE The value of this property will take the form of nn-host1:rpc-port. If the value of this property is unset the value of dfs.namenode.rpc-address will be used as the default.</td></tr><tr><td>dfs.namenode.servicerpc-bind-host</td><td></td><td>The actual address the service RPC server will bind to. If this optional address is set, it overrides only the hostname portion of dfs.namenode.servicerpc-address. It can also be specified per name node or name service for HA/Federation. This is useful for making the name node listen on all interfaces by setting it to 0.0.0.0.</td></tr><tr><td>dfs.namenode.secondary.http-address</td><td>0.0.0.0:50090</td><td>The secondary namenode http server address and port.</td></tr><tr><td>dfs.namenode.secondary.https-address</td><td>0.0.0.0:50091</td><td>The secondary namenode HTTPS server address and port.</td></tr><tr><td>dfs.datanode.address</td><td>0.0.0.0:50010</td><td>The datanode server address and port for data transfer.</td></tr><tr><td>dfs.datanode.http.address</td><td>0.0.0.0:50075</td><td>The datanode http server address and port.</td></tr><tr><td>dfs.datanode.ipc.address</td><td>0.0.0.0:50020</td><td>The datanode ipc server address and port.</td></tr><tr><td>dfs.datanode.handler.count</td><td>10</td><td>The number of server threads for the datanode.</td></tr><tr><td>dfs.namenode.http-address</td><td>0.0.0.0:50070</td><td>The address and the base port where the dfs namenode web ui will listen on.</td></tr><tr><td>dfs.namenode.http-bind-host</td><td></td><td>The actual adress the HTTP server will bind to. If this optional address is set, it overrides only the hostname portion of dfs.namenode.http-address. It can also be specified per name node or name service for HA/Federation. This is useful for making the name node HTTP server listen on all interfaces by setting it to 0.0.0.0.</td></tr><tr><td>dfs.https.enable</td><td>false</td><td>Deprecated. Use &quot;dfs.http.policy&quot; instead.</td></tr><tr><td>dfs.http.policy</td><td>HTTP_ONLY</td><td>Decide if HTTPS(SSL) is supported on HDFS This configures the HTTP endpoint for HDFS daemons: The following values are supported: - HTTP_ONLY : Service is provided only on http - HTTPS_ONLY : Service is provided only on https - HTTP_AND_HTTPS : Service is provided both on http and https</td></tr><tr><td>dfs.client.https.need-auth</td><td>false</td><td>Whether SSL client certificate authentication is required</td></tr><tr><td>dfs.client.cached.conn.retry</td><td>3</td><td>The number of times the HDFS client will pull a socket from the cache. Once this number is exceeded, the client will try to create a new socket.</td></tr><tr><td>dfs.https.server.keystore.resource</td><td>ssl-server.xml</td><td>Resource file from which ssl server keystore information will be extracted</td></tr><tr><td>dfs.client.https.keystore.resource</td><td>ssl-client.xml</td><td>Resource file from which ssl client keystore information will be extracted</td></tr><tr><td>dfs.datanode.https.address</td><td>0.0.0.0:50475</td><td>The datanode secure http server address and port.</td></tr><tr><td>dfs.namenode.https-address</td><td>0.0.0.0:50470</td><td>The namenode secure http server address and port.</td></tr><tr><td>dfs.namenode.https-bind-host</td><td></td><td>The actual adress the HTTPS server will bind to. If this optional address is set, it overrides only the hostname portion of dfs.namenode.https-address. It can also be specified per name node or name service for HA/Federation. This is useful for making the name node HTTPS server listen on all interfaces by setting it to 0.0.0.0.</td></tr><tr><td>dfs.datanode.dns.interface</td><td>default</td><td>The name of the Network Interface from which a data node should report its IP address.</td></tr><tr><td>dfs.datanode.dns.nameserver</td><td>default</td><td>The host name or IP address of the name server (DNS) which a DataNode should use to determine the host name used by the NameNode for communication and display purposes.</td></tr><tr><td>dfs.namenode.backup.address</td><td>0.0.0.0:50100</td><td>The backup node server address and port. If the port is 0 then the server will start on a free port.</td></tr><tr><td>dfs.namenode.backup.http-address</td><td>0.0.0.0:50105</td><td>The backup node http server address and port. If the port is 0 then the server will start on a free port.</td></tr><tr><td>dfs.namenode.replication.considerLoad</td><td>true</td><td>Decide if chooseTarget considers the target's load or not</td></tr><tr><td>dfs.default.chunk.view.size</td><td>32768</td><td>The number of bytes to view for a file on the browser.</td></tr><tr><td>dfs.datanode.du.reserved</td><td>0</td><td>Reserved space in bytes per volume. Always leave this much space free for non dfs use.</td></tr><tr><td>dfs.namenode.name.dir</td><td>file://${hadoop.tmp.dir}/dfs/name</td><td>Determines where on the local filesystem the DFS name node should store the name table(fsimage). If this is a comma-delimited list of directories then the name table is replicated in all of the directories, for redundancy.</td></tr><tr><td>dfs.namenode.name.dir.restore</td><td>false</td><td>Set to true to enable NameNode to attempt recovering a previously failed dfs.namenode.name.dir. When enabled, a recovery of any failed directory is attempted during checkpoint.</td></tr><tr><td>dfs.namenode.fs-limits.max-component-length</td><td>255</td><td>Defines the maximum number of bytes in UTF-8 encoding in each component of a path. A value of 0 will disable the check.</td></tr><tr><td>dfs.namenode.fs-limits.max-directory-items</td><td>1048576</td><td>Defines the maximum number of items that a directory may contain. A value of 0 will disable the check.</td></tr><tr><td>dfs.namenode.fs-limits.min-block-size</td><td>1048576</td><td>Minimum block size in bytes, enforced by the Namenode at create time. This prevents the accidental creation of files with tiny block sizes (and thus many blocks), which can degrade performance.</td></tr><tr><td>dfs.namenode.fs-limits.max-blocks-per-file</td><td>1048576</td><td>Maximum number of blocks per file, enforced by the Namenode on write. This prevents the creation of extremely large files which can degrade performance.</td></tr><tr><td>dfs.namenode.edits.dir</td><td dfs.namenode.name.dir="">$</td><td>Determines where on the local filesystem the DFS name node should store the transaction (edits) file. If this is a comma-delimited list of directories then the transaction file is replicated in all of the directories, for redundancy. Default value is same as dfs.namenode.name.dir</td></tr><tr><td>dfs.namenode.shared.edits.dir</td><td></td><td>A directory on shared storage between the multiple namenodes in an HA cluster. This directory will be written by the active and read by the standby in order to keep the namespaces synchronized. This directory does not need to be listed in dfs.namenode.edits.dir above. It should be left empty in a non-HA cluster.</td></tr><tr><td>dfs.namenode.edits.journal-plugin.qjournal</td><td>org.apache.hadoop.hdfs.qjournal.client.QuorumJournalManager</td><td></td></tr><tr><td>dfs.permissions.enabled</td><td>true</td><td>If &quot;true&quot;, enable permission checking in HDFS. If &quot;false&quot;, permission checking is turned off, but all other behavior is unchanged. Switching from one parameter value to the other does not change the mode, owner or group of files or directories.</td></tr><tr><td>dfs.permissions.superusergroup</td><td>supergroup</td><td>The name of the group of super-users. The value should be a single group name.</td></tr><tr><td>dfs.cluster.administrators</td><td></td><td>ACL for the admins, this configuration is used to control who can access the default servlets in the namenode, etc. The value should be a comma separated list of users and groups. The user list comes first and is separated by a space followed by the group list, e.g. &quot;user1,user2 group1,group2&quot;. Both users and groups are optional, so &quot;user1&quot;, &quot; group1&quot;, &quot;&quot;, &quot;user1 group1&quot;, &quot;user1,user2 group1,group2&quot; are all valid (note the leading space in &quot; group1&quot;). '<em>' grants access to all users and groups, e.g. '</em>', '* ' and ' *' are all valid.</td></tr><tr><td>dfs.namenode.acls.enabled</td><td>false</td><td>Set to true to enable support for HDFS ACLs (Access Control Lists). By default, ACLs are disabled. When ACLs are disabled, the NameNode rejects all RPCs related to setting or getting ACLs.</td></tr><tr><td>dfs.namenode.lazypersist.file.scrub.interval.sec</td><td>300</td><td>The NameNode periodically scans the namespace for LazyPersist files with missing blocks and unlinks them from the namespace. This configuration key controls the interval between successive scans. Set it to a negative value to disable this behavior.</td></tr><tr><td>dfs.block.access.token.enable</td><td>false</td><td>If &quot;true&quot;, access tokens are used as capabilities for accessing datanodes. If &quot;false&quot;, no access tokens are checked on accessing datanodes.</td></tr><tr><td>dfs.block.access.key.update.interval</td><td>600</td><td>Interval in minutes at which namenode updates its access keys.</td></tr><tr><td>dfs.block.access.token.lifetime</td><td>600</td><td>The lifetime of access tokens in minutes.</td></tr><tr><td>dfs.datanode.data.dir</td><td>file://${hadoop.tmp.dir}/dfs/data</td><td>Determines where on the local filesystem an DFS data node should store its blocks. If this is a comma-delimited list of directories, then data will be stored in all named directories, typically on different devices. Directories that do not exist are ignored.</td></tr><tr><td>dfs.datanode.data.dir.perm</td><td>700</td><td>Permissions for the directories on on the local filesystem where the DFS data node store its blocks. The permissions can either be octal or symbolic.</td></tr><tr><td>dfs.replication</td><td>3</td><td>Default block replication. The actual number of replications can be specified when the file is created. The default is used if replication is not specified in create time.</td></tr><tr><td>dfs.replication.max</td><td>512</td><td>Maximal block replication.</td></tr><tr><td>dfs.namenode.replication.min</td><td>1</td><td>Minimal block replication.</td></tr><tr><td>dfs.blocksize</td><td>134217728</td><td>The default block size for new files, in bytes. You can use the following suffix (case insensitive): k(kilo), m(mega), g(giga), t(tera), p(peta), e(exa) to specify the size (such as 128k, 512m, 1g, etc.), Or provide complete size in bytes (such as 134217728 for 128 MB).</td></tr><tr><td>dfs.client.block.write.retries</td><td>3</td><td>The number of retries for writing blocks to the data nodes, before we signal failure to the application.</td></tr><tr><td>dfs.client.block.write.replace-datanode-on-failure.enable</td><td>true</td><td>If there is a datanode/network failure in the write pipeline, DFSClient will try to remove the failed datanode from the pipeline and then continue writing with the remaining datanodes. As a result, the number of datanodes in the pipeline is decreased. The feature is to add new datanodes to the pipeline. This is a site-wide property to enable/disable the feature. When the cluster size is extremely small, e.g. 3 nodes or less, cluster administrators may want to set the policy to NEVER in the default configuration file or disable this feature. Otherwise, users may experience an unusually high rate of pipeline failures since it is impossible to find new datanodes for replacement. See also dfs.client.block.write.replace-datanode-on-failure.policy</td></tr><tr><td>dfs.client.block.write.replace-datanode-on-failure.policy</td><td>DEFAULT</td><td>This property is used only if the value of dfs.client.block.write.replace-datanode-on-failure.enable is true. ALWAYS: always add a new datanode when an existing datanode is removed. NEVER: never add a new datanode. DEFAULT: Let r be the replication number. Let n be the number of existing datanodes. Add a new datanode only if r is greater than or equal to 3 and either (1) floor(r/2) is greater than or equal to n; or (2) r is greater than n and the block is hflushed/appended.</td></tr><tr><td>dfs.client.block.write.replace-datanode-on-failure.best-effort</td><td>false</td><td>This property is used only if the value of dfs.client.block.write.replace-datanode-on-failure.enable is true. Best effort means that the client will try to replace a failed datanode in write pipeline (provided that the policy is satisfied), however, it continues the write operation in case that the datanode replacement also fails. Suppose the datanode replacement fails. false: An exception should be thrown so that the write will fail. true : The write should be resumed with the remaining datandoes. Note that setting this property to true allows writing to a pipeline with a smaller number of datanodes. As a result, it increases the probability of data loss.</td></tr><tr><td>dfs.blockreport.intervalMsec</td><td>21600000</td><td>Determines block reporting interval in milliseconds.</td></tr><tr><td>dfs.blockreport.initialDelay</td><td>0</td><td>Delay for first block report in seconds.</td></tr><tr><td>dfs.blockreport.split.threshold</td><td>1000000</td><td>If the number of blocks on the DataNode is below this threshold then it will send block reports for all Storage Directories in a single message. If the number of blocks exceeds this threshold then the DataNode will send block reports for each Storage Directory in separate messages. Set to zero to always split.</td></tr><tr><td>dfs.datanode.directoryscan.interval</td><td>21600</td><td>Interval in seconds for Datanode to scan data directories and reconcile the difference between blocks in memory and on the disk.</td></tr><tr><td>dfs.datanode.directoryscan.threads</td><td>1</td><td>How many threads should the threadpool used to compile reports for volumes in parallel have.</td></tr><tr><td>dfs.heartbeat.interval</td><td>3</td><td>Determines datanode heartbeat interval in seconds.</td></tr><tr><td>dfs.namenode.handler.count</td><td>10</td><td>The number of server threads for the namenode.</td></tr><tr><td>dfs.namenode.safemode.threshold-pct</td><td>0.999f</td><td>Specifies the percentage of blocks that should satisfy the minimal replication requirement defined by dfs.namenode.replication.min. Values less than or equal to 0 mean not to wait for any particular percentage of blocks before exiting safemode. Values greater than 1 will make safe mode permanent.</td></tr><tr><td>dfs.namenode.safemode.min.datanodes</td><td>0</td><td>Specifies the number of datanodes that must be considered alive before the name node exits safemode. Values less than or equal to 0 mean not to take the number of live datanodes into account when deciding whether to remain in safe mode during startup. Values greater than the number of datanodes in the cluster will make safe mode permanent.</td></tr><tr><td>dfs.namenode.safemode.extension</td><td>30000</td><td>Determines extension of safe mode in milliseconds after the threshold level is reached.</td></tr><tr><td>dfs.namenode.resource.check.interval</td><td>5000</td><td>The interval in milliseconds at which the NameNode resource checker runs. The checker calculates the number of the NameNode storage volumes whose available spaces are more than dfs.namenode.resource.du.reserved, and enters safemode if the number becomes lower than the minimum value specified by dfs.namenode.resource.checked.volumes.minimum.</td></tr><tr><td>dfs.namenode.resource.du.reserved</td><td>104857600</td><td>The amount of space to reserve/require for a NameNode storage directory in bytes. The default is 100MB.</td></tr><tr><td>dfs.namenode.resource.checked.volumes</td><td></td><td>A list of local directories for the NameNode resource checker to check in addition to the local edits directories.</td></tr><tr><td>dfs.namenode.resource.checked.volumes.minimum</td><td>1</td><td>The minimum number of redundant NameNode storage volumes required.</td></tr><tr><td>dfs.datanode.balance.bandwidthPerSec</td><td>1048576</td><td>Specifies the maximum amount of bandwidth that each datanode can utilize for the balancing purpose in term of the number of bytes per second.</td></tr><tr><td>dfs.hosts</td><td></td><td>Names a file that contains a list of hosts that are permitted to connect to the namenode. The full pathname of the file must be specified. If the value is empty, all hosts are permitted.</td></tr><tr><td>dfs.hosts.exclude</td><td></td><td>Names a file that contains a list of hosts that are not permitted to connect to the namenode. The full pathname of the file must be specified. If the value is empty, no hosts are excluded.</td></tr><tr><td>dfs.namenode.max.objects</td><td>0</td><td>The maximum number of files, directories and blocks dfs supports. A value of zero indicates no limit to the number of objects that dfs supports.</td></tr><tr><td>dfs.namenode.datanode.registration.ip-hostname-check</td><td>true</td><td>If true (the default), then the namenode requires that a connecting datanode's address must be resolved to a hostname. If necessary, a reverse DNS lookup is performed. All attempts to register a datanode from an unresolvable address are rejected. It is recommended that this setting be left on to prevent accidental registration of datanodes listed by hostname in the excludes file during a DNS outage. Only set this to false in environments where there is no infrastructure to support reverse DNS lookup.</td></tr><tr><td>dfs.namenode.decommission.interval</td><td>30</td><td>Namenode periodicity in seconds to check if decommission is complete.</td></tr><tr><td>dfs.namenode.decommission.nodes.per.interval</td><td>5</td><td>The number of nodes namenode checks if decommission is complete in each dfs.namenode.decommission.interval.</td></tr><tr><td>dfs.namenode.replication.interval</td><td>3</td><td>The periodicity in seconds with which the namenode computes repliaction work for datanodes.</td></tr><tr><td>dfs.namenode.accesstime.precision</td><td>3600000</td><td>The access time for HDFS file is precise upto this value. The default value is 1 hour. Setting a value of 0 disables access times for HDFS.</td></tr><tr><td>dfs.datanode.plugins</td><td></td><td>Comma-separated list of datanode plug-ins to be activated.</td></tr><tr><td>dfs.namenode.plugins</td><td></td><td>Comma-separated list of namenode plug-ins to be activated.</td></tr><tr><td>dfs.stream-buffer-size</td><td>4096</td><td>The size of buffer to stream files. The size of this buffer should probably be a multiple of hardware page size (4096 on Intel x86), and it determines how much data is buffered during read and write operations.</td></tr><tr><td>dfs.bytes-per-checksum</td><td>512</td><td>The number of bytes per checksum. Must not be larger than dfs.stream-buffer-size</td></tr><tr><td>dfs.client-write-packet-size</td><td>65536</td><td>Packet size for clients to write</td></tr><tr><td>dfs.client.write.exclude.nodes.cache.expiry.interval.millis</td><td>600000</td><td>The maximum period to keep a DN in the excluded nodes list at a client. After this period, in milliseconds, the previously excluded node(s) will be removed automatically from the cache and will be considered good for block allocations again. Useful to lower or raise in situations where you keep a file open for very long periods (such as a Write-Ahead-Log (WAL) file) to make the writer tolerant to cluster maintenance restarts. Defaults to 10 minutes.</td></tr><tr><td>dfs.namenode.checkpoint.dir</td><td>file://${hadoop.tmp.dir}/dfs/namesecondary</td><td>Determines where on the local filesystem the DFS secondary name node should store the temporary images to merge. If this is a comma-delimited list of directories then the image is replicated in all of the directories for redundancy.</td></tr><tr><td>dfs.namenode.checkpoint.edits.dir</td><td dfs.namenode.checkpoint.dir="">$</td><td>Determines where on the local filesystem the DFS secondary name node should store the temporary edits to merge. If this is a comma-delimited list of directoires then teh edits is replicated in all of the directoires for redundancy. Default value is same as dfs.namenode.checkpoint.dir</td></tr><tr><td>dfs.namenode.checkpoint.period</td><td>3600</td><td>The number of seconds between two periodic checkpoints.</td></tr><tr><td>dfs.namenode.checkpoint.txns</td><td>1000000</td><td>The Secondary NameNode or CheckpointNode will create a checkpoint of the namespace every 'dfs.namenode.checkpoint.txns' transactions, regardless of whether 'dfs.namenode.checkpoint.period' has expired.</td></tr><tr><td>dfs.namenode.checkpoint.check.period</td><td>60</td><td>The SecondaryNameNode and CheckpointNode will poll the NameNode every 'dfs.namenode.checkpoint.check.period' seconds to query the number of uncheckpointed transactions.</td></tr><tr><td>dfs.namenode.checkpoint.max-retries</td><td>3</td><td>The SecondaryNameNode retries failed checkpointing. If the failure occurs while loading fsimage or replaying edits, the number of retries is limited by this variable.</td></tr><tr><td>dfs.namenode.num.checkpoints.retained</td><td>2</td><td>The number of image checkpoint files that will be retained by the NameNode and Secondary NameNode in their storage directories. All edit logs necessary to recover an up-to-date namespace from the oldest retained checkpoint will also be retained.</td></tr><tr><td>dfs.namenode.num.extra.edits.retained</td><td>1000000</td><td>The number of extra transactions which should be retained beyond what is minimally necessary for a NN restart. This can be useful for audit purposes or for an HA setup where a remote Standby Node may have been offline for some time and need to have a longer backlog of retained edits in order to start again. Typically each edit is on the order of a few hundred bytes, so the default of 1 million edits should be on the order of hundreds of MBs or low GBs. NOTE: Fewer extra edits may be retained than value specified for this setting if doing so would mean that more segments would be retained than the number configured by dfs.namenode.max.extra.edits.segments.retained.</td></tr><tr><td>dfs.namenode.max.extra.edits.segments.retained</td><td>10000</td><td>The maximum number of extra edit log segments which should be retained beyond what is minimally necessary for a NN restart. When used in conjunction with dfs.namenode.num.extra.edits.retained, this configuration property serves to cap the number of extra edits files to a reasonable value.</td></tr><tr><td>dfs.namenode.delegation.key.update-interval</td><td>86400000</td><td>The update interval for master key for delegation tokens in the namenode in milliseconds.</td></tr><tr><td>dfs.namenode.delegation.token.max-lifetime</td><td>604800000</td><td>The maximum lifetime in milliseconds for which a delegation token is valid.</td></tr><tr><td>dfs.namenode.delegation.token.renew-interval</td><td>86400000</td><td>The renewal interval for delegation token in milliseconds.</td></tr><tr><td>dfs.datanode.failed.volumes.tolerated</td><td>0</td><td>The number of volumes that are allowed to fail before a datanode stops offering service. By default any volume failure will cause a datanode to shutdown.</td></tr><tr><td>dfs.image.compress</td><td>false</td><td>Should the dfs image be compressed?</td></tr><tr><td>dfs.image.compression.codec</td><td>org.apache.hadoop.io.compress.DefaultCodec</td><td>If the dfs image is compressed, how should they be compressed? This has to be a codec defined in io.compression.codecs.</td></tr><tr><td>dfs.image.transfer.timeout</td><td>60000</td><td>Socket timeout for image transfer in milliseconds. This timeout and the related dfs.image.transfer.bandwidthPerSec parameter should be configured such that normal image transfer can complete successfully. This timeout prevents client hangs when the sender fails during image transfer. This is socket timeout during image tranfer.</td></tr><tr><td>dfs.image.transfer.bandwidthPerSec</td><td>0</td><td>Maximum bandwidth used for image transfer in bytes per second. This can help keep normal namenode operations responsive during checkpointing. The maximum bandwidth and timeout in dfs.image.transfer.timeout should be set such that normal image transfers can complete successfully. A default value of 0 indicates that throttling is disabled.</td></tr><tr><td>dfs.image.transfer.chunksize</td><td>65536</td><td>Chunksize in bytes to upload the checkpoint. Chunked streaming is used to avoid internal buffering of contents of image file of huge size.</td></tr><tr><td>dfs.namenode.support.allow.format</td><td>true</td><td>Does HDFS namenode allow itself to be formatted? You may consider setting this to false for any production cluster, to avoid any possibility of formatting a running DFS.</td></tr><tr><td>dfs.datanode.max.transfer.threads</td><td>4096</td><td>Specifies the maximum number of threads to use for transferring data in and out of the DN.</td></tr><tr><td>dfs.datanode.readahead.bytes</td><td>4193404</td><td>While reading block files, if the Hadoop native libraries are available, the datanode can use the posix_fadvise system call to explicitly page data into the operating system buffer cache ahead of the current reader's position. This can improve performance especially when disks are highly contended. This configuration specifies the number of bytes ahead of the current read position which the datanode will attempt to read ahead. This feature may be disabled by configuring this property to 0. If the native libraries are not available, this configuration has no effect.</td></tr><tr><td>dfs.datanode.drop.cache.behind.reads</td><td>false</td><td>In some workloads, the data read from HDFS is known to be significantly large enough that it is unlikely to be useful to cache it in the operating system buffer cache. In this case, the DataNode may be configured to automatically purge all data from the buffer cache after it is delivered to the client. This behavior is automatically disabled for workloads which read only short sections of a block (e.g HBase random-IO workloads). This may improve performance for some workloads by freeing buffer cache spage usage for more cacheable data. If the Hadoop native libraries are not available, this configuration has no effect.</td></tr><tr><td>dfs.datanode.drop.cache.behind.writes</td><td>false</td><td>In some workloads, the data written to HDFS is known to be significantly large enough that it is unlikely to be useful to cache it in the operating system buffer cache. In this case, the DataNode may be configured to automatically purge all data from the buffer cache after it is written to disk. This may improve performance for some workloads by freeing buffer cache spage usage for more cacheable data. If the Hadoop native libraries are not available, this configuration has no effect.</td></tr><tr><td>dfs.datanode.sync.behind.writes</td><td>false</td><td>If this configuration is enabled, the datanode will instruct the operating system to enqueue all written data to the disk immediately after it is written. This differs from the usual OS policy which may wait for up to 30 seconds before triggering writeback. This may improve performance for some workloads by smoothing the IO profile for data written to disk. If the Hadoop native libraries are not available, this configuration has no effect.</td></tr><tr><td>dfs.client.failover.max.attempts</td><td>15</td><td>Expert only. The number of client failover attempts that should be made before the failover is considered failed.</td></tr><tr><td>dfs.client.failover.sleep.base.millis</td><td>500</td><td>Expert only. The time to wait, in milliseconds, between failover attempts increases exponentially as a function of the number of attempts made so far, with a random factor of +/- 50%. This option specifies the base value used in the failover calculation. The first failover will retry immediately. The 2nd failover attempt will delay at least dfs.client.failover.sleep.base.millis milliseconds. And so on.</td></tr><tr><td>dfs.client.failover.sleep.max.millis</td><td>15000</td><td>Expert only. The time to wait, in milliseconds, between failover attempts increases exponentially as a function of the number of attempts made so far, with a random factor of +/- 50%. This option specifies the maximum value to wait between failovers. Specifically, the time between two failover attempts will not exceed +/- 50% of dfs.client.failover.sleep.max.millis milliseconds.</td></tr><tr><td>dfs.client.failover.connection.retries</td><td>0</td><td>Expert only. Indicates the number of retries a failover IPC client will make to establish a server connection.</td></tr><tr><td>dfs.client.failover.connection.retries.on.timeouts</td><td>0</td><td>Expert only. The number of retry attempts a failover IPC client will make on socket timeout when establishing a server connection.</td></tr><tr><td>dfs.client.datanode-restart.timeout</td><td>30</td><td>Expert only. The time to wait, in seconds, from reception of an datanode shutdown notification for quick restart, until declaring the datanode dead and invoking the normal recovery mechanisms. The notification is sent by a datanode when it is being shutdown using the shutdownDatanode admin command with the upgrade option.</td></tr><tr><td>dfs.nameservices</td><td></td><td>Comma-separated list of nameservices.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2Rmcy5uYW1lc2VydmljZS5pZA==">dfs.nameservice.id</span></td><td></td><td>The ID of this nameservice. If the nameservice ID is not configured or more than one nameservice is configured for dfs.nameservices it is determined automatically by matching the local node's address with the configured address.</td></tr><tr><td>dfs.internal.nameservices</td><td></td><td>Comma-separated list of nameservices that belong to this cluster. Datanode will report to all the nameservices in this list. By default this is set to the value of dfs.nameservices.</td></tr><tr><td>dfs.ha.namenodes.EXAMPLENAMESERVICE</td><td></td><td>The prefix for a given nameservice, contains a comma-separated list of namenodes for a given nameservice (eg EXAMPLENAMESERVICE).</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2Rmcy5oYS5uYW1lbm9kZS5pZA==">dfs.ha.namenode.id</span></td><td></td><td>The ID of this namenode. If the namenode ID is not configured it is determined automatically by matching the local node's address with the configured address.</td></tr><tr><td>dfs.ha.log-roll.period</td><td>120</td><td>How often, in seconds, the StandbyNode should ask the active to roll edit logs. Since the StandbyNode only reads from finalized log segments, the StandbyNode will only be as up-to-date as how often the logs are rolled. Note that failover triggers a log roll so the StandbyNode will be up to date before it becomes active.</td></tr><tr><td>dfs.ha.tail-edits.period</td><td>60</td><td>How often, in seconds, the StandbyNode should check for new finalized log segments in the shared edits log.</td></tr><tr><td>dfs.ha.automatic-failover.enabled</td><td>false</td><td>Whether automatic failover is enabled. See the HDFS High Availability documentation for details on automatic HA configuration.</td></tr><tr><td>dfs.support.append</td><td>true</td><td>Does HDFS allow appends to files?</td></tr><tr><td>dfs.client.use.datanode.hostname</td><td>false</td><td>Whether clients should use datanode hostnames when connecting to datanodes.</td></tr><tr><td>dfs.datanode.use.datanode.hostname</td><td>false</td><td>Whether datanodes should use datanode hostnames when connecting to other datanodes for data transfer.</td></tr><tr><td>dfs.client.local.interfaces</td><td></td><td>A comma separated list of network interface names to use for data transfer between the client and datanodes. When creating a connection to read from or write to a datanode, the client chooses one of the specified interfaces at random and binds its socket to the IP of that interface. Individual names may be specified as either an interface name (eg &quot;eth0&quot;), a subinterface name (eg &quot;eth0:0&quot;), or an IP address (which may be specified using CIDR notation to match a range of IPs).</td></tr><tr><td>dfs.datanode.shared.file.descriptor.paths</td><td>/dev/shm,/tmp</td><td>A comma-separated list of paths to use when creating file descriptors that will be shared between the DataNode and the DFSClient. Typically we use /dev/shm, so that the file descriptors will not be written to disk. Systems that don't have /dev/shm will fall back to /tmp by default.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2Rmcy5zaG9ydC5jaXJjdWl0LnNoYXJlZC5tZW1vcnkud2F0Y2hlci5pbnRlcnJ1cHQuY2hlY2subXM=">dfs.short.circuit.shared.memory.watcher.interrupt.check.ms</span></td><td>60000</td><td>The length of time in milliseconds that the short-circuit shared memory watcher will go between checking for java interruptions sent from other threads. This is provided mainly for unit tests.</td></tr><tr><td>dfs.namenode.kerberos.internal.spnego.principal</td><td dfs.web.authentication.kerberos.principal="">$</td><td></td></tr><tr><td>dfs.secondary.namenode.kerberos.internal.spnego.principal</td><td dfs.web.authentication.kerberos.principal="">$</td><td></td></tr><tr><td>dfs.namenode.avoid.read.stale.datanode</td><td>false</td><td>Indicate whether or not to avoid reading from &quot;stale&quot; datanodes whose heartbeat messages have not been received by the namenode for more than a specified time interval. Stale datanodes will be moved to the end of the node list returned for reading. See dfs.namenode.avoid.write.stale.datanode for a similar setting for writes.</td></tr><tr><td>dfs.namenode.avoid.write.stale.datanode</td><td>false</td><td>Indicate whether or not to avoid writing to &quot;stale&quot; datanodes whose heartbeat messages have not been received by the namenode for more than a specified time interval. Writes will avoid using stale datanodes unless more than a configured ratio (dfs.namenode.write.stale.datanode.ratio) of datanodes are marked as stale. See dfs.namenode.avoid.read.stale.datanode for a similar setting for reads.</td></tr><tr><td>dfs.namenode.stale.datanode.interval</td><td>30000</td><td>Default time interval for marking a datanode as &quot;stale&quot;, i.e., if the namenode has not received heartbeat msg from a datanode for more than this time interval, the datanode will be marked and treated as &quot;stale&quot; by default. The stale interval cannot be too small since otherwise this may cause too frequent change of stale states. We thus set a minimum stale interval value (the default value is 3 times of heartbeat interval) and guarantee that the stale interval cannot be less than the minimum value. A stale data node is avoided during lease/block recovery. It can be conditionally avoided for reads (see dfs.namenode.avoid.read.stale.datanode) and for writes (see dfs.namenode.avoid.write.stale.datanode).</td></tr><tr><td>dfs.namenode.write.stale.datanode.ratio</td><td>0.5f</td><td>When the ratio of number stale datanodes to total datanodes marked is greater than this ratio, stop avoiding writing to stale nodes so as to prevent causing hotspots.</td></tr><tr><td>dfs.namenode.invalidate.work.pct.per.iteration</td><td>0.32f</td><td><em>Note</em>: Advanced property. Change with caution. This determines the percentage amount of block invalidations (deletes) to do over a single DN heartbeat deletion command. The final deletion count is determined by applying this percentage to the number of live nodes in the system. The resultant number is the number of blocks from the deletion list chosen for proper invalidation over a single heartbeat of a single DN. Value should be a positive, non-zero percentage in float notation (X.Yf), with 1.0f meaning 100%.</td></tr><tr><td>dfs.namenode.replication.work.multiplier.per.iteration</td><td>2</td><td><em>Note</em>: Advanced property. Change with caution. This determines the total amount of block transfers to begin in parallel at a DN, for replication, when such a command list is being sent over a DN heartbeat by the NN. The actual number is obtained by multiplying this multiplier with the total number of live nodes in the cluster. The result number is the number of blocks to begin transfers immediately for, per DN heartbeat. This number can be any positive, non-zero integer.</td></tr><tr><td>nfs.server.port</td><td>2049</td><td>Specify the port number used by Hadoop NFS.</td></tr><tr><td>nfs.mountd.port</td><td>4242</td><td>Specify the port number used by Hadoop mount daemon.</td></tr><tr><td>nfs.dump.dir</td><td>/tmp/.hdfs-nfs</td><td>This directory is used to temporarily save out-of-order writes before writing to HDFS. For each file, the out-of-order writes are dumped after they are accumulated to exceed certain threshold (e.g., 1MB) in memory. One needs to make sure the directory has enough space.</td></tr><tr><td>nfs.rtmax</td><td>1048576</td><td>This is the maximum size in bytes of a READ request supported by the NFS gateway. If you change this, make sure you also update the nfs mount's rsize(add rsize= # of bytes to the mount directive).</td></tr><tr><td>nfs.wtmax</td><td>1048576</td><td>This is the maximum size in bytes of a WRITE request supported by the NFS gateway. If you change this, make sure you also update the nfs mount's wsize(add wsize= # of bytes to the mount directive).</td></tr><tr><td>nfs.keytab.file</td><td></td><td><em>Note</em>: Advanced property. Change with caution. This is the path to the keytab file for the hdfs-nfs gateway. This is required when the cluster is kerberized.</td></tr><tr><td>nfs.kerberos.principal</td><td></td><td><em>Note</em>: Advanced property. Change with caution. This is the name of the kerberos principal. This is required when the cluster is <span class="exturl" data-url="aHR0cDovL2tlcmJlcml6ZWQuSXQ=">kerberized.It</span> must be of this format: nfs-gateway-user/nfs-gateway-host@kerberos-realm</td></tr><tr><td>nfs.allow.insecure.ports</td><td>true</td><td>When set to false, client connections originating from unprivileged ports (those above 1023) will be rejected. This is to ensure that clients connecting to this NFS Gateway must have had root privilege on the machine where they're connecting from.</td></tr><tr><td>dfs.webhdfs.enabled</td><td>true</td><td>Enable WebHDFS (REST API) in Namenodes and Datanodes.</td></tr><tr><td>hadoop.fuse.connection.timeout</td><td>300</td><td>The minimum number of seconds that we'll cache libhdfs connection objects in fuse_dfs. Lower values will result in lower memory consumption; higher values may speed up access by avoiding the overhead of creating new connection objects.</td></tr><tr><td>hadoop.fuse.timer.period</td><td>5</td><td>The number of seconds between cache expiry checks in fuse_dfs. Lower values will result in fuse_dfs noticing changes to Kerberos ticket caches more quickly.</td></tr><tr><td>dfs.metrics.percentiles.intervals</td><td></td><td>Comma-delimited set of integers denoting the desired rollover intervals (in seconds) for percentile latency metrics on the Namenode and Datanode. By default, percentile latency metrics are disabled.</td></tr><tr><td>dfs.encrypt.data.transfer</td><td>false</td><td>Whether or not actual block data that is read/written from/to HDFS should be encrypted on the wire. This only needs to be set on the NN and DNs, clients will deduce this automatically. It is possible to override this setting per connection by specifying custom logic via dfs.trustedchannel.resolver.class.</td></tr><tr><td>dfs.encrypt.data.transfer.algorithm</td><td></td><td>This value may be set to either &quot;3des&quot; or &quot;rc4&quot;. If nothing is set, then the configured JCE default on the system is used (usually 3DES.) It is widely believed that 3DES is more cryptographically secure, but RC4 is substantially faster. Note that if AES is supported by both the client and server then this encryption algorithm will only be used to initially transfer keys for AES. (See dfs.encrypt.data.transfer.cipher.suites.)</td></tr><tr><td>dfs.encrypt.data.transfer.cipher.suites</td><td></td><td>This value may be either undefined or AES/CTR/NoPadding. If defined, then dfs.encrypt.data.transfer uses the specified cipher suite for data encryption. If not defined, then only the algorithm specified in dfs.encrypt.data.transfer.algorithm is used. By default, the property is not defined.</td></tr><tr><td>dfs.encrypt.data.transfer.cipher.key.bitlength</td><td>128</td><td>The key bitlength negotiated by dfsclient and datanode for encryption. This value may be set to either 128, 192 or 256.</td></tr><tr><td>dfs.trustedchannel.resolver.class</td><td></td><td>TrustedChannelResolver is used to determine whether a channel is trusted for plain data transfer. The TrustedChannelResolver is invoked on both client and server side. If the resolver indicates that the channel is trusted, then the data transfer will not be encrypted even if dfs.encrypt.data.transfer is set to true. The default implementation returns false indicating that the channel is not trusted.</td></tr><tr><td>dfs.data.transfer.protection</td><td></td><td>A comma-separated list of SASL protection values used for secured connections to the DataNode when reading or writing block data. Possible values are authentication, integrity and privacy. authentication means authentication only and no integrity or privacy; integrity implies authentication and integrity are enabled; and privacy implies all of authentication, integrity and privacy are enabled. If dfs.encrypt.data.transfer is set to true, then it supersedes the setting for dfs.data.transfer.protection and enforces that all connections must use a specialized encrypted SASL handshake. This property is ignored for connections to a DataNode listening on a privileged port. In this case, it is assumed that the use of a privileged port establishes sufficient trust.</td></tr><tr><td>dfs.data.transfer.saslproperties.resolver.class</td><td></td><td>SaslPropertiesResolver used to resolve the QOP used for a connection to the DataNode when reading or writing block data. If not specified, the value of hadoop.security.saslproperties.resolver.class is used as the default value.</td></tr><tr><td>dfs.datanode.hdfs-blocks-metadata.enabled</td><td>false</td><td>Boolean which enables backend datanode-side support for the experimental DistributedFileSystem#getFileVBlockStorageLocations API.</td></tr><tr><td>dfs.client.file-block-storage-locations.num-threads</td><td>10</td><td>Number of threads used for making parallel RPCs in DistributedFileSystem#getFileBlockStorageLocations().</td></tr><tr><td>dfs.client.file-block-storage-locations.timeout.millis</td><td>1000</td><td>Timeout (in milliseconds) for the parallel RPCs made in DistributedFileSystem#getFileBlockStorageLocations().</td></tr><tr><td>dfs.journalnode.rpc-address</td><td>0.0.0.0:8485</td><td>The JournalNode RPC server address and port.</td></tr><tr><td>dfs.journalnode.http-address</td><td>0.0.0.0:8480</td><td>The address and port the JournalNode HTTP server listens on. If the port is 0 then the server will start on a free port.</td></tr><tr><td>dfs.journalnode.https-address</td><td>0.0.0.0:8481</td><td>The address and port the JournalNode HTTPS server listens on. If the port is 0 then the server will start on a free port.</td></tr><tr><td>dfs.namenode.audit.loggers</td><td>default</td><td>List of classes implementing audit loggers that will receive audit events. These should be implementations of org.apache.hadoop.hdfs.server.namenode.AuditLogger. The special value &quot;default&quot; can be used to reference the default audit logger, which uses the configured log system. Installing custom audit loggers may affect the performance and stability of the NameNode. Refer to the custom logger's documentation for more details.</td></tr><tr><td>dfs.datanode.available-space-volume-choosing-policy.balanced-space-threshold</td><td>10737418240</td><td>Only used when the dfs.datanode.fsdataset.volume.choosing.policy is set to org.apache.hadoop.hdfs.server.datanode.fsdataset.AvailableSpaceVolumeChoosingPolicy. This setting controls how much DN volumes are allowed to differ in terms of bytes of free disk space before they are considered imbalanced. If the free space of all the volumes are within this range of each other, the volumes will be considered balanced and block assignments will be done on a pure round robin basis.</td></tr><tr><td>dfs.datanode.available-space-volume-choosing-policy.balanced-space-preference-fraction</td><td>0.75f</td><td>Only used when the dfs.datanode.fsdataset.volume.choosing.policy is set to org.apache.hadoop.hdfs.server.datanode.fsdataset.AvailableSpaceVolumeChoosingPolicy. This setting controls what percentage of new block allocations will be sent to volumes with more available disk space than others. This setting should be in the range 0.0 - 1.0, though in practice 0.5 - 1.0, since there should be no reason to prefer that volumes with less available disk space receive more block allocations.</td></tr><tr><td>dfs.namenode.edits.noeditlogchannelflush</td><td>false</td><td>Specifies whether to flush edit log file channel. When set, expensive FileChannel#force calls are skipped and synchronous disk writes are enabled instead by opening the edit log file with RandomAccessFile(&quot;rws&quot;) flags. This can significantly improve the performance of edit log writes on the Windows platform. Note that the behavior of the &quot;rws&quot; flags is platform and hardware specific and might not provide the same level of guarantees as FileChannel#force. For example, the write will skip the disk-cache on SAS and SCSI devices while it might not on SATA devices. This is an expert level setting, change with caution.</td></tr><tr><td>dfs.client.cache.drop.behind.writes</td><td></td><td>Just like dfs.datanode.drop.cache.behind.writes, this setting causes the page cache to be dropped behind HDFS writes, potentially freeing up more memory for other uses. Unlike dfs.datanode.drop.cache.behind.writes, this is a client-side setting rather than a setting for the entire datanode. If present, this setting will override the DataNode default. If the native libraries are not available to the DataNode, this configuration has no effect.</td></tr><tr><td>dfs.client.cache.drop.behind.reads</td><td></td><td>Just like dfs.datanode.drop.cache.behind.reads, this setting causes the page cache to be dropped behind HDFS reads, potentially freeing up more memory for other uses. Unlike dfs.datanode.drop.cache.behind.reads, this is a client-side setting rather than a setting for the entire datanode. If present, this setting will override the DataNode default. If the native libraries are not available to the DataNode, this configuration has no effect.</td></tr><tr><td>dfs.client.cache.readahead</td><td></td><td>When using remote reads, this setting causes the datanode to read ahead in the block file using posix_fadvise, potentially decreasing I/O wait times. Unlike dfs.datanode.readahead.bytes, this is a client-side setting rather than a setting for the entire datanode. If present, this setting will override the DataNode default. When using local reads, this setting determines how much readahead we do in BlockReaderLocal. If the native libraries are not available to the DataNode, this configuration has no effect.</td></tr><tr><td>dfs.namenode.enable.retrycache</td><td>true</td><td>This enables the retry cache on the namenode. Namenode tracks for non-idempotent requests the corresponding response. If a client retries the request, the response from the retry cache is sent. Such operations are tagged with annotation @AtMostOnce in namenode protocols. It is recommended that this flag be set to true. Setting it to false, will result in clients getting failure responses to retried request. This flag must be enabled in HA setup for transparent fail-overs. The entries in the cache have expiration time configurable using dfs.namenode.retrycache.expirytime.millis.</td></tr><tr><td>dfs.namenode.retrycache.expirytime.millis</td><td>600000</td><td>The time for which retry cache entries are retained.</td></tr><tr><td>dfs.namenode.retrycache.heap.percent</td><td>0.03f</td><td>This parameter configures the heap size allocated for retry cache (excluding the response cached). This corresponds to approximately 4096 entries for every 64MB of namenode process java heap size. Assuming retry cache entry expiration time (configured using dfs.namenode.retrycache.expirytime.millis) of 10 minutes, this enables retry cache to support 7 operations per second sustained for 10 minutes. As the heap size is increased, the operation rate linearly increases.</td></tr><tr><td>dfs.client.mmap.enabled</td><td>true</td><td>If this is set to false, the client won't attempt to perform memory-mapped reads.</td></tr><tr><td>dfs.client.mmap.cache.size</td><td>256</td><td>When zero-copy reads are used, the DFSClient keeps a cache of recently used memory mapped regions. This parameter controls the maximum number of entries that we will keep in that cache. The larger this number is, the more file descriptors we will potentially use for memory-mapped files. mmaped files also use virtual address space. You may need to increase your ulimit virtual address space limits before increasing the client mmap cache size. Note that you can still do zero-copy reads when this size is set to 0.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2Rmcy5jbGllbnQubW1hcC5jYWNoZS50aW1lb3V0Lm1z">dfs.client.mmap.cache.timeout.ms</span></td><td>3600000</td><td>The minimum length of time that we will keep an mmap entry in the cache between uses. If an entry is in the cache longer than this, and nobody uses it, it will be removed by a background thread.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2Rmcy5jbGllbnQubW1hcC5yZXRyeS50aW1lb3V0Lm1z">dfs.client.mmap.retry.timeout.ms</span></td><td>300000</td><td>The minimum amount of time that we will wait before retrying a failed mmap operation.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2Rmcy5jbGllbnQuc2hvcnQuY2lyY3VpdC5yZXBsaWNhLnN0YWxlLnRocmVzaG9sZC5tcw==">dfs.client.short.circuit.replica.stale.threshold.ms</span></td><td>1800000</td><td>The maximum amount of time that we will consider a short-circuit replica to be valid, if there is no communication from the DataNode. After this time has elapsed, we will re-fetch the short-circuit replica even if it is in the cache.</td></tr><tr><td>dfs.namenode.path.based.cache.block.map.allocation.percent</td><td>0.25</td><td>The percentage of the Java heap which we will allocate to the cached blocks map. The cached blocks map is a hash map which uses chained hashing. Smaller maps may be accessed more slowly if the number of cached blocks is large; larger maps will consume more memory.</td></tr><tr><td>dfs.datanode.max.locked.memory</td><td>0</td><td>The amount of memory in bytes to use for caching of block replicas in memory on the datanode. The datanode's maximum locked memory soft ulimit (RLIMIT_MEMLOCK) must be set to at least this value, else the datanode will abort on startup. By default, this parameter is set to 0, which disables in-memory caching. If the native libraries are not available to the DataNode, this configuration has no effect.</td></tr><tr><td>dfs.namenode.list.cache.directives.num.responses</td><td>100</td><td>This value controls the number of cache directives that the NameNode will send over the wire in response to a listDirectives RPC.</td></tr><tr><td>dfs.namenode.list.cache.pools.num.responses</td><td>100</td><td>This value controls the number of cache pools that the NameNode will send over the wire in response to a listPools RPC.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2Rmcy5uYW1lbm9kZS5wYXRoLmJhc2VkLmNhY2hlLnJlZnJlc2guaW50ZXJ2YWwubXM=">dfs.namenode.path.based.cache.refresh.interval.ms</span></td><td>30000</td><td>The amount of milliseconds between subsequent path cache rescans. Path cache rescans are when we calculate which blocks should be cached, and on what datanodes. By default, this parameter is set to 30 seconds.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2Rmcy5uYW1lbm9kZS5wYXRoLmJhc2VkLmNhY2hlLnJldHJ5LmludGVydmFsLm1z">dfs.namenode.path.based.cache.retry.interval.ms</span></td><td>30000</td><td>When the NameNode needs to uncache something that is cached, or cache something that is not cached, it must direct the DataNodes to do so by sending a DNA_CACHE or DNA_UNCACHE command in response to a DataNode heartbeat. This parameter controls how frequently the NameNode will resend these commands.</td></tr><tr><td>dfs.datanode.fsdatasetcache.max.threads.per.volume</td><td>4</td><td>The maximum number of threads per volume to use for caching new data on the datanode. These threads consume both I/O and CPU. This can affect normal datanode operations.</td></tr><tr><td>dfs.cachereport.intervalMsec</td><td>10000</td><td>Determines cache reporting interval in milliseconds. After this amount of time, the DataNode sends a full report of its cache state to the NameNode. The NameNode uses the cache report to update its map of cached blocks to DataNode locations. This configuration has no effect if in-memory caching has been disabled by setting dfs.datanode.max.locked.memory to 0 (which is the default). If the native libraries are not available to the DataNode, this configuration has no effect.</td></tr><tr><td>dfs.namenode.edit.log.autoroll.multiplier.threshold</td><td>2.0</td><td>Determines when an active namenode will roll its own edit log. The actual threshold (in number of edits) is determined by multiplying this value by dfs.namenode.checkpoint.txns. This prevents extremely large edit files from accumulating on the active namenode, which can cause timeouts during namenode startup and pose an administrative hassle. This behavior is intended as a failsafe for when the standby or secondary namenode fail to roll the edit log by the normal checkpoint threshold.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2Rmcy5uYW1lbm9kZS5lZGl0LmxvZy5hdXRvcm9sbC5jaGVjay5pbnRlcnZhbC5tcw==">dfs.namenode.edit.log.autoroll.check.interval.ms</span></td><td>300000</td><td>How often an active namenode will check if it needs to roll its edit log, in milliseconds.</td></tr><tr><td>dfs.webhdfs.user.provider.user.pattern</td><td><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>[A-Za-z0-9._-]*[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">]</mo><mo stretchy="false">?</mo></mrow><annotation encoding="application/x-tex">]?</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mclose">]</span><span class="mclose">?</span></span></span></span></td><td>Valid pattern for user and group names for webhdfs, it must be a valid java regex.</td></tr><tr><td>dfs.client.context</td><td>default</td><td>The name of the DFSClient context that we should use. Clients that share a context share a socket cache and short-circuit cache, among other things. You should only change this if you don't want to share with another set of threads.</td></tr><tr><td>dfs.client.read.shortcircuit</td><td>false</td><td>This configuration parameter turns on short-circuit local reads.</td></tr><tr><td>dfs.domain.socket.path</td><td></td><td>Optional. This is a path to a UNIX domain socket that will be used for communication between the DataNode and local HDFS clients. If the string &quot;_PORT&quot; is present in this path, it will be replaced by the TCP port of the DataNode.</td></tr><tr><td>dfs.client.read.shortcircuit.skip.checksum</td><td>false</td><td>If this configuration parameter is set, short-circuit local reads will skip checksums. This is normally not recommended, but it may be useful for special setups. You might consider using this if you are doing your own checksumming outside of HDFS.</td></tr><tr><td>dfs.client.read.shortcircuit.streams.cache.size</td><td>256</td><td>The DFSClient maintains a cache of recently opened file descriptors. This parameter controls the size of that cache. Setting this higher will use more file descriptors, but potentially provide better performance on workloads involving lots of seeks.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2Rmcy5jbGllbnQucmVhZC5zaG9ydGNpcmN1aXQuc3RyZWFtcy5jYWNoZS5leHBpcnkubXM=">dfs.client.read.shortcircuit.streams.cache.expiry.ms</span></td><td>300000</td><td>This controls the minimum amount of time file descriptors need to sit in the client cache context before they can be closed for being inactive for too long.</td></tr><tr><td>dfs.datanode.shared.file.descriptor.paths</td><td>/dev/shm,/tmp</td><td>Comma separated paths to the directory on which shared memory segments are created. The client and the DataNode exchange information via this shared memory segment. It tries paths in order until creation of shared memory segment succeeds.</td></tr><tr><td>dfs.client.use.legacy.blockreader.local</td><td>false</td><td>Legacy short-circuit reader implementation based on HDFS-2246 is used if this configuration parameter is true. This is for the platforms other than Linux where the new implementation based on HDFS-347 is not available.</td></tr><tr><td>dfs.block.local-path-access.user</td><td></td><td>Comma separated list of the users allowd to open block files on legacy short-circuit local read.</td></tr><tr><td>dfs.client.domain.socket.data.traffic</td><td>false</td><td>This control whether we will try to pass normal data traffic over UNIX domain socket rather than over TCP socket on node-local data transfer. This is currently experimental and turned off by default.</td></tr><tr><td>dfs.namenode.reject-unresolved-dn-topology-mapping</td><td>false</td><td>If the value is set to true, then namenode will reject datanode registration if the topology mapping for a datanode is not resolved and NULL is returned (script defined by <span class="exturl" data-url="aHR0cDovL25ldC50b3BvbG9neS5zY3JpcHQuZmlsZS5uYW1l">net.topology.script.file.name</span> fails to execute). Otherwise, datanode will be registered and the default rack will be assigned as the topology path. Topology paths are important for data resiliency, since they define fault domains. Thus it may be unwanted behavior to allow datanode registration with the default rack if the resolving topology failed.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2Rmcy5jbGllbnQuc2xvdy5pby53YXJuaW5nLnRocmVzaG9sZC5tcw==">dfs.client.slow.io.warning.threshold.ms</span></td><td>30000</td><td>The threshold in milliseconds at which we will log a slow io warning in a dfsclient. By default, this parameter is set to 30000 milliseconds (30 seconds).</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2Rmcy5kYXRhbm9kZS5zbG93LmlvLndhcm5pbmcudGhyZXNob2xkLm1z">dfs.datanode.slow.io.warning.threshold.ms</span></td><td>300</td><td>The threshold in milliseconds at which we will log a slow io warning in a datanode. By default, this parameter is set to 300 milliseconds.</td></tr><tr><td>dfs.namenode.xattrs.enabled</td><td>true</td><td>Whether support for extended attributes is enabled on the NameNode.</td></tr><tr><td>dfs.namenode.fs-limits.max-xattrs-per-inode</td><td>32</td><td>Maximum number of extended attributes per inode.</td></tr><tr><td>dfs.namenode.fs-limits.max-xattr-size</td><td>16384</td><td>The maximum combined size of the name and value of an extended attribute in bytes.</td></tr><tr><td>dfs.namenode.startup.delay.block.deletion.sec</td><td>0</td><td>The delay in seconds at which we will pause the blocks deletion after Namenode startup. By default it's disabled. In the case a directory has large number of directories and files are deleted, suggested delay is one hour to give the administrator enough time to notice large number of pending deletion blocks and take corrective action.</td></tr><tr><td>dfs.namenode.list.encryption.zones.num.responses</td><td>100</td><td>When listing encryption zones, the maximum number of zones that will be returned in a batch. Fetching the list incrementally in batches improves namenode performance.</td></tr><tr><td>dfs.namenode.inotify.max.events.per.rpc</td><td>1000</td><td>Maximum number of events that will be sent to an inotify client in a single RPC response. The default value attempts to amortize away the overhead for this RPC while avoiding huge memory requirements for the client and NameNode (1000 events should consume no more than 1 MB.)</td></tr><tr><td>dfs.user.home.dir.prefix</td><td>/user</td><td>The directory to prepend to user name to get the user's home direcotry.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2Rmcy5kYXRhbm9kZS5jYWNoZS5yZXZvY2F0aW9uLnRpbWVvdXQubXM=">dfs.datanode.cache.revocation.timeout.ms</span></td><td>900000</td><td>When the DFSClient reads from a block file which the DataNode is caching, the DFSClient can skip verifying checksums. The DataNode will keep the block file in cache until the client is done. If the client takes an unusually long time, though, the DataNode may need to evict the block file from the cache anyway. This value controls how long the DataNode will wait for the client to release a replica that it is reading without checksums.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2Rmcy5kYXRhbm9kZS5jYWNoZS5yZXZvY2F0aW9uLnBvbGxpbmcubXM=">dfs.datanode.cache.revocation.polling.ms</span></td><td>500</td><td>How often the DataNode should poll to see if the clients have stopped using a replica that the DataNode wants to uncache.</td></tr><tr><td>dfs.datanode.block.id.layout.upgrade.threads</td><td>12</td><td>The number of threads to use when creating hard links from current to previous blocks during upgrade of a DataNode to block ID-based block layout (see HDFS-6482 for details on the layout).</td></tr><tr><td>dfs.encryption.key.provider.uri</td><td></td><td>The KeyProvider to use when interacting with encryption keys used when reading and writing to an encryption zone.</td></tr><tr><td>dfs.storage.policy.enabled</td><td>true</td><td>Allow users to change the storage policy on files and directories.</td></tr><tr><td>dfs.namenode.legacy-oiv-image.dir</td><td></td><td>Determines where to save the namespace in the old fsimage format during checkpointing by standby NameNode or SecondaryNameNode. Users can dump the contents of the old format fsimage by oiv_legacy command. If the value is not specified, old format fsimage will not be saved in checkpoint.</td></tr><tr><td>dfs.datanode.bp-ready.timeout</td><td>20</td><td>The maximum wait time for datanode to be ready before failing the received request. Setting this to 0 fails requests right away if the datanode is not yet registered with the namenode. This wait time reduces initial request failures after datanode restart.</td></tr></tbody></table><p>mapred-site.xml</p><table><thead><tr><th>name</th><th>value</th><th>description</th></tr></thead><tbody><tr><td>mapreduce.jobtracker.jobhistory.location</td><td></td><td>If job tracker is static the history files are stored in this single well known place. If No value is set here, by default, it is in the local file system at ${hadoop.log.dir}/history.</td></tr><tr><td>mapreduce.jobtracker.jobhistory.task.numberprogresssplits</td><td>12</td><td>Every task attempt progresses from 0.0 to 1.0 [unless it fails or is killed]. We record, for each task attempt, certain statistics over each twelfth of the progress range. You can change the number of intervals we divide the entire range of progress into by setting this property. Higher values give more precision to the recorded data, but costs more memory in the job tracker at runtime. Each increment in this attribute costs 16 bytes per running task.</td></tr><tr><td>mapreduce.job.userhistorylocation</td><td></td><td>User can specify a location to store the history files of a particular job. If nothing is specified, the logs are stored in output directory. The files are stored in &quot;_logs/history/&quot; in the directory. User can stop logging by giving the value &quot;none&quot;.</td></tr><tr><td>mapreduce.jobtracker.jobhistory.completed.location</td><td></td><td>The completed job history files are stored at this single well known location. If nothing is specified, the files are stored at ${mapreduce.jobtracker.jobhistory.location}/done.</td></tr><tr><td>mapreduce.job.committer.setup.cleanup.needed</td><td>true</td><td>true, if job needs job-setup and job-cleanup. false, otherwise</td></tr><tr><td>mapreduce.task.io.sort.factor</td><td>10</td><td>The number of streams to merge at once while sorting files. This determines the number of open file handles.</td></tr><tr><td>mapreduce.task.io.sort.mb</td><td>100</td><td>The total amount of buffer memory to use while sorting files, in megabytes. By default, gives each merge stream 1MB, which should minimize seeks.</td></tr><tr><td>mapreduce.map.sort.spill.percent</td><td>0.80</td><td>The soft limit in the serialization buffer. Once reached, a thread will begin to spill the contents to disk in the background. Note that collection will not block if this threshold is exceeded while a spill is already in progress, so spills may be larger than this threshold when it is set to less than .5</td></tr><tr><td>mapreduce.jobtracker.address</td><td>local</td><td>The host and port that the MapReduce job tracker runs at. If &quot;local&quot;, then jobs are run in-process as a single map and reduce task.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL21hcHJlZHVjZS5sb2NhbC5jbGllbnRmYWN0b3J5LmNsYXNzLm5hbWU=">mapreduce.local.clientfactory.class.name</span></td><td>org.apache.hadoop.mapred.LocalClientFactory</td><td>This the client factory that is responsible for creating local job runner client</td></tr><tr><td>mapreduce.jobtracker.http.address</td><td>0.0.0.0:50030</td><td>The job tracker http server address and port the server will listen on. If the port is 0 then the server will start on a free port.</td></tr><tr><td>mapreduce.jobtracker.handler.count</td><td>10</td><td>The number of server threads for the JobTracker. This should be roughly 4% of the number of tasktracker nodes.</td></tr><tr><td>mapreduce.tasktracker.report.address</td><td>127.0.0.1:0</td><td>The interface and port that task tracker server listens on. Since it is only connected to by the tasks, it uses the local interface. EXPERT ONLY. Should only be changed if your host does not have the loopback interface.</td></tr><tr><td>mapreduce.cluster.local.dir</td><td>${hadoop.tmp.dir}/mapred/local</td><td>The local directory where MapReduce stores intermediate data files. May be a comma-separated list of directories on different devices in order to spread disk i/o. Directories that do not exist are ignored.</td></tr><tr><td>mapreduce.jobtracker.system.dir</td><td>${hadoop.tmp.dir}/mapred/system</td><td>The directory where MapReduce stores control files.</td></tr><tr><td>mapreduce.jobtracker.staging.root.dir</td><td>${hadoop.tmp.dir}/mapred/staging</td><td>The root of the staging area for users' job files In practice, this should be the directory where users' home directories are located (usually /user)</td></tr><tr><td>mapreduce.cluster.temp.dir</td><td>${hadoop.tmp.dir}/mapred/temp</td><td>A shared directory for temporary files.</td></tr><tr><td>mapreduce.tasktracker.local.dir.minspacestart</td><td>0</td><td>If the space in mapreduce.cluster.local.dir drops under this, do not ask for more tasks. Value in bytes.</td></tr><tr><td>mapreduce.tasktracker.local.dir.minspacekill</td><td>0</td><td>If the space in mapreduce.cluster.local.dir drops under this, do not ask more tasks until all the current ones have finished and cleaned up. Also, to save the rest of the tasks we have running, kill one of them, to clean up some space. Start with the reduce tasks, then go with the ones that have finished the least. Value in bytes.</td></tr><tr><td>mapreduce.jobtracker.expire.trackers.interval</td><td>600000</td><td>Expert: The time-interval, in miliseconds, after which a tasktracker is declared 'lost' if it doesn't send heartbeats.</td></tr><tr><td>mapreduce.tasktracker.instrumentation</td><td>org.apache.hadoop.mapred.TaskTrackerMetricsInst</td><td>Expert: The instrumentation class to associate with each TaskTracker.</td></tr><tr><td>mapreduce.tasktracker.resourcecalculatorplugin</td><td></td><td>Name of the class whose instance will be used to query resource information on the tasktracker. The class must be an instance of org.apache.hadoop.util.ResourceCalculatorPlugin. If the value is null, the tasktracker attempts to use a class appropriate to the platform. Currently, the only platform supported is Linux.</td></tr><tr><td>mapreduce.tasktracker.taskmemorymanager.monitoringinterval</td><td>5000</td><td>The interval, in milliseconds, for which the tasktracker waits between two cycles of monitoring its tasks' memory usage. Used only if tasks' memory management is enabled via mapred.tasktracker.tasks.maxmemory.</td></tr><tr><td>mapreduce.tasktracker.tasks.sleeptimebeforesigkill</td><td>5000</td><td>The time, in milliseconds, the tasktracker waits for sending a SIGKILL to a task, after it has been sent a SIGTERM. This is currently not used on WINDOWS where tasks are just sent a SIGTERM.</td></tr><tr><td>mapreduce.job.maps</td><td>2</td><td>The default number of map tasks per job. Ignored when mapreduce.jobtracker.address is &quot;local&quot;.</td></tr><tr><td>mapreduce.job.reduces</td><td>1</td><td>The default number of reduce tasks per job. Typically set to 99% of the cluster's reduce capacity, so that if a node fails the reduces can still be executed in a single wave. Ignored when mapreduce.jobtracker.address is &quot;local&quot;.</td></tr><tr><td>mapreduce.jobtracker.restart.recover</td><td>false</td><td>&quot;true&quot; to enable (job) recovery upon restart, &quot;false&quot; to start afresh</td></tr><tr><td>mapreduce.jobtracker.jobhistory.block.size</td><td>3145728</td><td>The block size of the job history file. Since the job recovery uses job history, its important to dump job history to disk as soon as possible. Note that this is an expert level parameter. The default value is set to 3 MB.</td></tr><tr><td>mapreduce.jobtracker.taskscheduler</td><td>org.apache.hadoop.mapred.JobQueueTaskScheduler</td><td>The class responsible for scheduling the tasks.</td></tr><tr><td>mapreduce.job.reducer.preempt.delay.sec</td><td>0</td><td>The threshold (in seconds) after which an unsatisfied mapper request triggers reducer preemption when there is no anticipated headroom. If set to 0 or a negative value, the reducer is preempted as soon as lack of headroom is detected. Default is 0.</td></tr><tr><td>mapreduce.job.reducer.unconditional-preempt.delay.sec</td><td>300</td><td>The threshold (in seconds) after which an unsatisfied mapper request triggers a forced reducer preemption irrespective of the anticipated headroom. By default, it is set to 5 mins. Setting it to 0 leads to immediate reducer preemption. Setting to -1 disables this preemption altogether.</td></tr><tr><td>mapreduce.job.max.split.locations</td><td>10</td><td>The max number of block locations to store for each split for locality calculation.</td></tr><tr><td>mapreduce.job.split.metainfo.maxsize</td><td>10000000</td><td>The maximum permissible size of the split metainfo file. The JobTracker won't attempt to read split metainfo files bigger than the configured value. No limits if set to -1.</td></tr><tr><td>mapreduce.jobtracker.taskscheduler.maxrunningtasks.perjob</td><td></td><td>The maximum number of running tasks for a job before it gets preempted. No limits if undefined.</td></tr><tr><td>mapreduce.map.maxattempts</td><td>4</td><td>Expert: The maximum number of attempts per map task. In other words, framework will try to execute a map task these many number of times before giving up on it.</td></tr><tr><td>mapreduce.reduce.maxattempts</td><td>4</td><td>Expert: The maximum number of attempts per reduce task. In other words, framework will try to execute a reduce task these many number of times before giving up on it.</td></tr><tr><td>mapreduce.reduce.shuffle.fetch.retry.enabled</td><td yarn.nodemanager.recovery.enabled="">$</td><td>Set to enable fetch retry during host restart.</td></tr><tr><td>mapreduce.reduce.shuffle.fetch.retry.interval-ms</td><td>1000</td><td>Time of interval that fetcher retry to fetch again when some non-fatal failure happens because of some events like NM restart.</td></tr><tr><td>mapreduce.reduce.shuffle.fetch.retry.timeout-ms</td><td>30000</td><td>Timeout value for fetcher to retry to fetch again when some non-fatal failure happens because of some events like NM restart.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL21hcHJlZHVjZS5yZWR1Y2Uuc2h1ZmZsZS5yZXRyeS1kZWxheS5tYXgubXM=">mapreduce.reduce.shuffle.retry-delay.max.ms</span></td><td>60000</td><td>The maximum number of ms the reducer will delay before retrying to download map data.</td></tr><tr><td>mapreduce.reduce.shuffle.parallelcopies</td><td>5</td><td>The default number of parallel transfers run by reduce during the copy(shuffle) phase.</td></tr><tr><td>mapreduce.reduce.shuffle.connect.timeout</td><td>180000</td><td>Expert: The maximum amount of time (in milli seconds) reduce task spends in trying to connect to a tasktracker for getting map output.</td></tr><tr><td>mapreduce.reduce.shuffle.read.timeout</td><td>180000</td><td>Expert: The maximum amount of time (in milli seconds) reduce task waits for map output data to be available for reading after obtaining connection.</td></tr><tr><td>mapreduce.shuffle.connection-keep-alive.enable</td><td>false</td><td>set to true to support keep-alive connections.</td></tr><tr><td>mapreduce.shuffle.connection-keep-alive.timeout</td><td>5</td><td>The number of seconds a shuffle client attempts to retain http connection. Refer &quot;Keep-Alive: timeout=&quot; header in Http specification</td></tr><tr><td>mapreduce.task.timeout</td><td>600000</td><td>The number of milliseconds before a task will be terminated if it neither reads an input, writes an output, nor updates its status string. A value of 0 disables the timeout.</td></tr><tr><td>mapreduce.tasktracker.map.tasks.maximum</td><td>2</td><td>The maximum number of map tasks that will be run simultaneously by a task tracker.</td></tr><tr><td>mapreduce.tasktracker.reduce.tasks.maximum</td><td>2</td><td>The maximum number of reduce tasks that will be run simultaneously by a task tracker.</td></tr><tr><td>mapreduce.map.memory.mb</td><td>1024</td><td>The amount of memory to request from the scheduler for each map task.</td></tr><tr><td>mapreduce.map.cpu.vcores</td><td>1</td><td>The number of virtual cores to request from the scheduler for each map task.</td></tr><tr><td>mapreduce.reduce.memory.mb</td><td>1024</td><td>The amount of memory to request from the scheduler for each reduce task.</td></tr><tr><td>mapreduce.reduce.cpu.vcores</td><td>1</td><td>The number of virtual cores to request from the scheduler for each reduce task.</td></tr><tr><td>mapreduce.jobtracker.retiredjobs.cache.size</td><td>1000</td><td>The number of retired job status to keep in the cache.</td></tr><tr><td>mapreduce.tasktracker.outofband.heartbeat</td><td>false</td><td>Expert: Set this to true to let the tasktracker send an out-of-band heartbeat on task-completion for better latency.</td></tr><tr><td>mapreduce.jobtracker.jobhistory.lru.cache.size</td><td>5</td><td>The number of job history files loaded in memory. The jobs are loaded when they are first accessed. The cache is cleared based on LRU.</td></tr><tr><td>mapreduce.jobtracker.instrumentation</td><td>org.apache.hadoop.mapred.JobTrackerMetricsInst</td><td>Expert: The instrumentation class to associate with each JobTracker.</td></tr><tr><td>mapred.child.java.opts</td><td>-Xmx200m</td><td>Java opts for the task processes. The following symbol, if present, will be interpolated: @taskid@ is replaced by current TaskID. Any other occurrences of '@' will go unchanged. For example, to enable verbose gc logging to a file named for the taskid in /tmp and to set the heap maximum to be a gigabyte, pass a 'value' of: -Xmx1024m -verbose:gc -Xloggc:/tmp/@taskid@.gc Usage of -Djava.library.path can cause programs to no longer function if hadoop native libraries are used. These values should instead be set as part of LD_LIBRARY_PATH in the map / reduce JVM env using the mapreduce.map.env and mapreduce.reduce.env config settings.</td></tr><tr><td>mapred.child.env</td><td></td><td>User added environment variables for the task processes. Example : 1) A=foo This will set the env variable A to foo 2) B=$B:c This is inherit nodemanager's B env variable on Unix. 3) B=%B%;c This is inherit nodemanager's B env variable on Windows.</td></tr><tr><td>mapreduce.admin.user.env</td><td></td><td>Expert: Additional execution environment entries for map and reduce task processes. This is not an additive property. You must preserve the original value if you want your map and reduce tasks to have access to native libraries (compression, etc). When this value is empty, the command to set execution envrionment will be OS dependent: For linux, use LD_LIBRARY_PATH=$HADOOP_COMMON_HOME/lib/native. For windows, use PATH = %PATH%;%HADOOP_COMMON_HOME%\bin.</td></tr><tr><td>mapreduce.task.tmp.dir</td><td>./tmp</td><td>To set the value of tmp directory for map and reduce tasks. If the value is an absolute path, it is directly assigned. Otherwise, it is prepended with task's working directory. The java tasks are executed with option -Djava.io.tmpdir='the absolute path of the tmp dir'. Pipes and streaming are set with environment variable, TMPDIR='the absolute path of the tmp dir'</td></tr><tr><td>mapreduce.map.log.level</td><td>INFO</td><td>The logging level for the map task. The allowed levels are: OFF, FATAL, ERROR, WARN, INFO, DEBUG, TRACE and ALL.</td></tr><tr><td>mapreduce.reduce.log.level</td><td>INFO</td><td>The logging level for the reduce task. The allowed levels are: OFF, FATAL, ERROR, WARN, INFO, DEBUG, TRACE and ALL.</td></tr><tr><td>mapreduce.map.cpu.vcores</td><td>1</td><td>The number of virtual cores required for each map task.</td></tr><tr><td>mapreduce.reduce.cpu.vcores</td><td>1</td><td>The number of virtual cores required for each reduce task.</td></tr><tr><td>mapreduce.reduce.merge.inmem.threshold</td><td>1000</td><td>The threshold, in terms of the number of files for the in-memory merge process. When we accumulate threshold number of files we initiate the in-memory merge and spill to disk. A value of 0 or less than 0 indicates we want to DON'T have any threshold and instead depend only on the ramfs's memory consumption to trigger the merge.</td></tr><tr><td>mapreduce.reduce.shuffle.merge.percent</td><td>0.66</td><td>The usage threshold at which an in-memory merge will be initiated, expressed as a percentage of the total memory allocated to storing in-memory map outputs, as defined by mapreduce.reduce.shuffle.input.buffer.percent.</td></tr><tr><td>mapreduce.reduce.shuffle.input.buffer.percent</td><td>0.70</td><td>The percentage of memory to be allocated from the maximum heap size to storing map outputs during the shuffle.</td></tr><tr><td>mapreduce.reduce.input.buffer.percent</td><td>0.0</td><td>The percentage of memory- relative to the maximum heap size- to retain map outputs during the reduce. When the shuffle is concluded, any remaining map outputs in memory must consume less than this threshold before the reduce can begin.</td></tr><tr><td>mapreduce.reduce.shuffle.memory.limit.percent</td><td>0.25</td><td>Expert: Maximum percentage of the in-memory limit that a single shuffle can consume</td></tr><tr><td>mapreduce.shuffle.ssl.enabled</td><td>false</td><td>Whether to use SSL for for the Shuffle HTTP endpoints.</td></tr><tr><td>mapreduce.shuffle.ssl.file.buffer.size</td><td>65536</td><td>Buffer size for reading spills from file when using SSL.</td></tr><tr><td>mapreduce.shuffle.max.connections</td><td>0</td><td>Max allowed connections for the shuffle. Set to 0 (zero) to indicate no limit on the number of connections.</td></tr><tr><td>mapreduce.shuffle.max.threads</td><td>0</td><td>Max allowed threads for serving shuffle connections. Set to zero to indicate the default of 2 times the number of available processors (as reported by Runtime.availableProcessors()). Netty is used to serve requests, so a thread is not needed for each connection.</td></tr><tr><td>mapreduce.shuffle.transferTo.allowed</td><td></td><td>This option can enable/disable using nio transferTo method in the shuffle phase. NIO transferTo does not perform well on windows in the shuffle phase. Thus, with this configuration property it is possible to disable it, in which case custom transfer method will be used. Recommended value is false when running Hadoop on Windows. For Linux, it is recommended to set it to true. If nothing is set then the default value is false for Windows, and true for Linux.</td></tr><tr><td>mapreduce.shuffle.transfer.buffer.size</td><td>131072</td><td>This property is used only if mapreduce.shuffle.transferTo.allowed is set to false. In that case, this property defines the size of the buffer used in the buffer copy code for the shuffle phase. The size of this buffer determines the size of the IO requests.</td></tr><tr><td>mapreduce.reduce.markreset.buffer.percent</td><td>0.0</td><td>The percentage of memory -relative to the maximum heap size- to be used for caching values when using the mark-reset functionality.</td></tr><tr><td>mapreduce.map.speculative</td><td>true</td><td>If true, then multiple instances of some map tasks may be executed in parallel.</td></tr><tr><td>mapreduce.reduce.speculative</td><td>true</td><td>If true, then multiple instances of some reduce tasks may be executed in parallel.</td></tr><tr><td>mapreduce.job.speculative.speculativecap</td><td>0.1</td><td>The max percent (0-1) of running tasks that can be speculatively re-executed at any time.</td></tr><tr><td>mapreduce.job.map.output.collector.class</td><td>org.apache.hadoop.mapred.MapTask$MapOutputBuffer</td><td>The MapOutputCollector implementation(s) to use. This may be a comma-separated list of class names, in which case the map task will try to initialize each of the collectors in turn. The first to successfully initialize will be used.</td></tr><tr><td>mapreduce.job.speculative.slowtaskthreshold</td><td>1.0</td><td>The number of standard deviations by which a task's ave progress-rates must be lower than the average of all running tasks' for the task to be considered too slow.</td></tr><tr><td>mapreduce.job.speculative.slownodethreshold</td><td>1.0</td><td>The number of standard deviations by which a Task Tracker's ave map and reduce progress-rates (finishTime-dispatchTime) must be lower than the average of all successful map/reduce task's for the TT to be considered too slow to give a speculative task to.</td></tr><tr><td>mapreduce.job.jvm.numtasks</td><td>1</td><td>How many tasks to run per jvm. If set to -1, there is no limit.</td></tr><tr><td>mapreduce.job.ubertask.enable</td><td>false</td><td>Whether to enable the small-jobs &quot;ubertask&quot; optimization, which runs &quot;sufficiently small&quot; jobs sequentially within a single JVM. &quot;Small&quot; is defined by the following maxmaps, maxreduces, and maxbytes settings. Note that configurations for application masters also affect the &quot;Small&quot; definition - yarn.app.mapreduce.am.resource.mb must be larger than both mapreduce.map.memory.mb and mapreduce.reduce.memory.mb, and yarn.app.mapreduce.am.resource.cpu-vcores must be larger than both mapreduce.map.cpu.vcores and mapreduce.reduce.cpu.vcores to enable ubertask. Users may override this value.</td></tr><tr><td>mapreduce.job.ubertask.maxmaps</td><td>9</td><td>Threshold for number of maps, beyond which job is considered too big for the ubertasking optimization. Users may override this value, but only downward.</td></tr><tr><td>mapreduce.job.ubertask.maxreduces</td><td>1</td><td>Threshold for number of reduces, beyond which job is considered too big for the ubertasking optimization. CURRENTLY THE CODE CANNOT SUPPORT MORE THAN ONE REDUCE and will ignore larger values. (Zero is a valid max, however.) Users may override this value, but only downward.</td></tr><tr><td>mapreduce.job.ubertask.maxbytes</td><td></td><td>Threshold for number of input bytes, beyond which job is considered too big for the ubertasking optimization. If no value is specified, dfs.block.size is used as a default. Be sure to specify a default value in mapred-site.xml if the underlying filesystem is not HDFS. Users may override this value, but only downward.</td></tr><tr><td>mapreduce.job.emit-timeline-data</td><td>false</td><td>Specifies if the Application Master should emit timeline data to the timeline server. Individual jobs can override this value.</td></tr><tr><td>mapreduce.input.fileinputformat.split.minsize</td><td>0</td><td>The minimum size chunk that map input should be split into. Note that some file formats may have minimum split sizes that take priority over this setting.</td></tr><tr><td>mapreduce.input.fileinputformat.list-status.num-threads</td><td>1</td><td>The number of threads to use to list and fetch block locations for the specified input paths. Note: multiple threads should not be used if a custom non thread-safe path filter is used.</td></tr><tr><td>mapreduce.jobtracker.maxtasks.perjob</td><td>-1</td><td>The maximum number of tasks for a single job. A value of -1 indicates that there is no maximum.</td></tr><tr><td>mapreduce.input.lineinputformat.linespermap</td><td>1</td><td>When using NLineInputFormat, the number of lines of input data to include in each split.</td></tr><tr><td>mapreduce.client.submit.file.replication</td><td>10</td><td>The replication level for submitted job files. This should be around the square root of the number of nodes.</td></tr><tr><td>mapreduce.tasktracker.dns.interface</td><td>default</td><td>The name of the Network Interface from which a task tracker should report its IP address.</td></tr><tr><td>mapreduce.tasktracker.dns.nameserver</td><td>default</td><td>The host name or IP address of the name server (DNS) which a TaskTracker should use to determine the host name used by the JobTracker for communication and display purposes.</td></tr><tr><td>mapreduce.tasktracker.http.threads</td><td>40</td><td>The number of worker threads that for the http server. This is used for map output fetching</td></tr><tr><td>mapreduce.tasktracker.http.address</td><td>0.0.0.0:50060</td><td>The task tracker http server address and port. If the port is 0 then the server will start on a free port.</td></tr><tr><td>mapreduce.task.files.preserve.failedtasks</td><td>false</td><td>Should the files for failed tasks be kept. This should only be used on jobs that are failing, because the storage is never reclaimed. It also prevents the map outputs from being erased from the reduce directory as they are consumed.</td></tr><tr><td>mapreduce.output.fileoutputformat.compress</td><td>false</td><td>Should the job outputs be compressed?</td></tr><tr><td>mapreduce.output.fileoutputformat.compress.type</td><td>RECORD</td><td>If the job outputs are to compressed as SequenceFiles, how should they be compressed? Should be one of NONE, RECORD or BLOCK.</td></tr><tr><td>mapreduce.output.fileoutputformat.compress.codec</td><td>org.apache.hadoop.io.compress.DefaultCodec</td><td>If the job outputs are compressed, how should they be compressed?</td></tr><tr><td>mapreduce.map.output.compress</td><td>false</td><td>Should the outputs of the maps be compressed before being sent across the network. Uses SequenceFile compression.</td></tr><tr><td>mapreduce.map.output.compress.codec</td><td>org.apache.hadoop.io.compress.DefaultCodec</td><td>If the map outputs are compressed, how should they be compressed?</td></tr><tr><td>map.sort.class</td><td>org.apache.hadoop.util.QuickSort</td><td>The default sort class for sorting keys.</td></tr><tr><td>mapreduce.task.userlog.limit.kb</td><td>0</td><td>The maximum size of user-logs of each task in KB. 0 disables the cap.</td></tr><tr><td>yarn.app.mapreduce.am.container.log.limit.kb</td><td>0</td><td>The maximum size of the MRAppMaster attempt container logs in KB. 0 disables the cap.</td></tr><tr><td>yarn.app.mapreduce.task.container.log.backups</td><td>0</td><td>Number of backup files for task logs when using ContainerRollingLogAppender (CRLA). See org.apache.log4j.RollingFileAppender.maxBackupIndex. By default, ContainerLogAppender (CLA) is used, and container logs are not rolled. CRLA is enabled for tasks when both mapreduce.task.userlog.limit.kb and yarn.app.mapreduce.task.container.log.backups are greater than zero.</td></tr><tr><td>yarn.app.mapreduce.am.container.log.backups</td><td>0</td><td>Number of backup files for the ApplicationMaster logs when using ContainerRollingLogAppender (CRLA). See org.apache.log4j.RollingFileAppender.maxBackupIndex. By default, ContainerLogAppender (CLA) is used, and container logs are not rolled. CRLA is enabled for the ApplicationMaster when both mapreduce.task.userlog.limit.kb and yarn.app.mapreduce.am.container.log.backups are greater than zero.</td></tr><tr><td>mapreduce.job.userlog.retain.hours</td><td>24</td><td>The maximum time, in hours, for which the user-logs are to be retained after the job completion.</td></tr><tr><td>mapreduce.jobtracker.hosts.filename</td><td></td><td>Names a file that contains the list of nodes that may connect to the jobtracker. If the value is empty, all hosts are permitted.</td></tr><tr><td>mapreduce.jobtracker.hosts.exclude.filename</td><td></td><td>Names a file that contains the list of hosts that should be excluded by the jobtracker. If the value is empty, no hosts are excluded.</td></tr><tr><td>mapreduce.jobtracker.heartbeats.in.second</td><td>100</td><td>Expert: Approximate number of heart-beats that could arrive at JobTracker in a second. Assuming each RPC can be processed in 10msec, the default value is made 100 RPCs in a second.</td></tr><tr><td>mapreduce.jobtracker.tasktracker.maxblacklists</td><td>4</td><td>The number of blacklists for a taskTracker by various jobs after which the task tracker could be blacklisted across all jobs. The tracker will be given a tasks later (after a day). The tracker will become a healthy tracker after a restart.</td></tr><tr><td>mapreduce.job.maxtaskfailures.per.tracker</td><td>3</td><td>The number of task-failures on a tasktracker of a given job after which new tasks of that job aren't assigned to it. It MUST be less than mapreduce.map.maxattempts and mapreduce.reduce.maxattempts otherwise the failed task will never be tried on a different node.</td></tr><tr><td>mapreduce.client.output.filter</td><td>FAILED</td><td>The filter for controlling the output of the task's userlogs sent to the console of the JobClient. The permissible options are: NONE, KILLED, FAILED, SUCCEEDED and ALL.</td></tr><tr><td>mapreduce.client.completion.pollinterval</td><td>5000</td><td>The interval (in milliseconds) between which the JobClient polls the JobTracker for updates about job status. You may want to set this to a lower value to make tests run faster on a single node system. Adjusting this value in production may lead to unwanted client-server traffic.</td></tr><tr><td>mapreduce.client.progressmonitor.pollinterval</td><td>1000</td><td>The interval (in milliseconds) between which the JobClient reports status to the console and checks for job completion. You may want to set this to a lower value to make tests run faster on a single node system. Adjusting this value in production may lead to unwanted client-server traffic.</td></tr><tr><td>mapreduce.jobtracker.persist.jobstatus.active</td><td>true</td><td>Indicates if persistency of job status information is active or not.</td></tr><tr><td>mapreduce.jobtracker.persist.jobstatus.hours</td><td>1</td><td>The number of hours job status information is persisted in DFS. The job status information will be available after it drops of the memory queue and between jobtracker restarts. With a zero value the job status information is not persisted at all in DFS.</td></tr><tr><td>mapreduce.jobtracker.persist.jobstatus.dir</td><td>/jobtracker/jobsInfo</td><td>The directory where the job status information is persisted in a file system to be available after it drops of the memory queue and between jobtracker restarts.</td></tr><tr><td>mapreduce.task.profile</td><td>false</td><td>To set whether the system should collect profiler information for some of the tasks in this job? The information is stored in the user log directory. The value is &quot;true&quot; if task profiling is enabled.</td></tr><tr><td>mapreduce.task.profile.maps</td><td>0-2</td><td>To set the ranges of map tasks to profile. mapreduce.task.profile has to be set to true for the value to be accounted.</td></tr><tr><td>mapreduce.task.profile.reduces</td><td>0-2</td><td>To set the ranges of reduce tasks to profile. mapreduce.task.profile has to be set to true for the value to be accounted.</td></tr><tr><td>mapreduce.task.profile.params</td><td>-agentlib:hprof=cpu=samples,heap=sites,force=n,thread=y,verbose=n,file=%s</td><td>JVM profiler parameters used to profile map and reduce task attempts. This string may contain a single format specifier %s that will be replaced by the path to profile.out in the task attempt log directory. To specify different profiling options for map tasks and reduce tasks, more specific parameters mapreduce.task.profile.map.params and mapreduce.task.profile.reduce.params should be used.</td></tr><tr><td>mapreduce.task.profile.map.params</td><td mapreduce.task.profile.params="">$</td><td>Map-task-specific JVM profiler parameters. See mapreduce.task.profile.params</td></tr><tr><td>mapreduce.task.profile.reduce.params</td><td mapreduce.task.profile.params="">$</td><td>Reduce-task-specific JVM profiler parameters. See mapreduce.task.profile.params</td></tr><tr><td>mapreduce.task.skip.start.attempts</td><td>2</td><td>The number of Task attempts AFTER which skip mode will be kicked off. When skip mode is kicked off, the tasks reports the range of records which it will process next, to the TaskTracker. So that on failures, TT knows which ones are possibly the bad records. On further executions, those are skipped.</td></tr><tr><td>mapreduce.map.skip.proc.count.autoincr</td><td>true</td><td>The flag which if set to true, SkipBadRecords.COUNTER_MAP_PROCESSED_RECORDS is incremented by MapRunner after invoking the map function. This value must be set to false for applications which process the records asynchronously or buffer the input records. For example streaming. In such cases applications should increment this counter on their own.</td></tr><tr><td>mapreduce.reduce.skip.proc.count.autoincr</td><td>true</td><td>The flag which if set to true, SkipBadRecords.COUNTER_REDUCE_PROCESSED_GROUPS is incremented by framework after invoking the reduce function. This value must be set to false for applications which process the records asynchronously or buffer the input records. For example streaming. In such cases applications should increment this counter on their own.</td></tr><tr><td>mapreduce.job.skip.outdir</td><td></td><td>If no value is specified here, the skipped records are written to the output directory at _logs/skip. User can stop writing skipped records by giving the value &quot;none&quot;.</td></tr><tr><td>mapreduce.map.skip.maxrecords</td><td>0</td><td>The number of acceptable skip records surrounding the bad record PER bad record in mapper. The number includes the bad record as well. To turn the feature of detection/skipping of bad records off, set the value to 0. The framework tries to narrow down the skipped range by retrying until this threshold is met OR all attempts get exhausted for this task. Set the value to Long.MAX_VALUE to indicate that framework need not try to narrow down. Whatever records(depends on application) get skipped are acceptable.</td></tr><tr><td>mapreduce.reduce.skip.maxgroups</td><td>0</td><td>The number of acceptable skip groups surrounding the bad group PER bad group in reducer. The number includes the bad group as well. To turn the feature of detection/skipping of bad groups off, set the value to 0. The framework tries to narrow down the skipped range by retrying until this threshold is met OR all attempts get exhausted for this task. Set the value to Long.MAX_VALUE to indicate that framework need not try to narrow down. Whatever groups(depends on application) get skipped are acceptable.</td></tr><tr><td>mapreduce.ifile.readahead</td><td>true</td><td>Configuration key to enable/disable IFile readahead.</td></tr><tr><td>mapreduce.ifile.readahead.bytes</td><td>4194304</td><td>Configuration key to set the IFile readahead length in bytes.</td></tr><tr><td>mapreduce.jobtracker.taskcache.levels</td><td>2</td><td>This is the max level of the task cache. For example, if the level is 2, the tasks cached are at the host level and at the rack level.</td></tr><tr><td>mapreduce.job.queuename</td><td>default</td><td>Queue to which a job is submitted. This must match one of the queues defined in mapred-queues.xml for the system. Also, the ACL setup for the queue must allow the current user to submit a job to the queue. Before specifying a queue, ensure that the system is configured with the queue, and access is allowed for submitting jobs to the queue.</td></tr><tr><td>mapreduce.job.tags</td><td></td><td>Tags for the job that will be passed to YARN at submission time. Queries to YARN for applications can filter on these tags.</td></tr><tr><td>mapreduce.cluster.acls.enabled</td><td>false</td><td>Specifies whether ACLs should be checked for authorization of users for doing various queue and job level operations. ACLs are disabled by default. If enabled, access control checks are made by JobTracker and TaskTracker when requests are made by users for queue operations like submit job to a queue and kill a job in the queue and job operations like viewing the job-details (See mapreduce.job.acl-view-job) or for modifying the job (See mapreduce.job.acl-modify-job) using Map/Reduce APIs, RPCs or via the console and web user interfaces. For enabling this flag(mapreduce.cluster.acls.enabled), this is to be set to true in mapred-site.xml on JobTracker node and on all TaskTracker nodes.</td></tr><tr><td>mapreduce.job.acl-modify-job</td><td></td><td>Job specific access-control list for 'modifying' the job. It is only used if authorization is enabled in Map/Reduce by setting the configuration property mapreduce.cluster.acls.enabled to true. This specifies the list of users and/or groups who can do modification operations on the job. For specifying a list of users and groups the format to use is &quot;user1,user2 group1,group&quot;. If set to '*', it allows all users/groups to modify this job. If set to ' '(i.e. space), it allows none. This configuration is used to guard all the modifications with respect to this job and takes care of all the following operations: o killing this job o killing a task of this job, failing a task of this job o setting the priority of this job Each of these operations are also protected by the per-queue level ACL &quot;acl-administer-jobs&quot; configured via mapred-queues.xml. So a caller should have the authorization to satisfy either the queue-level ACL or the job-level ACL. Irrespective of this ACL configuration, (a) job-owner, (b) the user who started the cluster, (c) members of an admin configured supergroup configured via mapreduce.cluster.permissions.supergroup and (d) queue administrators of the queue to which this job was submitted to configured via acl-administer-jobs for the specific queue in mapred-queues.xml can do all the modification operations on a job. By default, nobody else besides job-owner, the user who started the cluster, members of supergroup and queue administrators can perform modification operations on a job.</td></tr><tr><td>mapreduce.job.acl-view-job</td><td></td><td>Job specific access-control list for 'viewing' the job. It is only used if authorization is enabled in Map/Reduce by setting the configuration property mapreduce.cluster.acls.enabled to true. This specifies the list of users and/or groups who can view private details about the job. For specifying a list of users and groups the format to use is &quot;user1,user2 group1,group&quot;. If set to '*', it allows all users/groups to modify this job. If set to ' '(i.e. space), it allows none. This configuration is used to guard some of the job-views and at present only protects APIs that can return possibly sensitive information of the job-owner like o job-level counters o task-level counters o tasks' diagnostic information o task-logs displayed on the TaskTracker web-UI and o job.xml showed by the JobTracker's web-UI Every other piece of information of jobs is still accessible by any other user, for e.g., JobStatus, JobProfile, list of jobs in the queue, etc. Irrespective of this ACL configuration, (a) job-owner, (b) the user who started the cluster, (c) members of an admin configured supergroup configured via mapreduce.cluster.permissions.supergroup and (d) queue administrators of the queue to which this job was submitted to configured via acl-administer-jobs for the specific queue in mapred-queues.xml can do all the view operations on a job. By default, nobody else besides job-owner, the user who started the cluster, memebers of supergroup and queue administrators can perform view operations on a job.</td></tr><tr><td>mapreduce.tasktracker.indexcache.mb</td><td>10</td><td>The maximum memory that a task tracker allows for the index cache that is used when serving map outputs to reducers.</td></tr><tr><td>mapreduce.job.token.tracking.ids.enabled</td><td>false</td><td>Whether to write tracking ids of tokens to job-conf. When true, the configuration property &quot;mapreduce.job.token.tracking.ids&quot; is set to the token-tracking-ids of the job</td></tr><tr><td>mapreduce.job.token.tracking.ids</td><td></td><td>When mapreduce.job.token.tracking.ids.enabled is set to true, this is set by the framework to the token-tracking-ids used by the job.</td></tr><tr><td>mapreduce.task.merge.progress.records</td><td>10000</td><td>The number of records to process during merge before sending a progress notification to the TaskTracker.</td></tr><tr><td>mapreduce.task.combine.progress.records</td><td>10000</td><td>The number of records to process during combine output collection before sending a progress notification.</td></tr><tr><td>mapreduce.job.reduce.slowstart.completedmaps</td><td>0.05</td><td>Fraction of the number of maps in the job which should be complete before reduces are scheduled for the job.</td></tr><tr><td>mapreduce.job.complete.cancel.delegation.tokens</td><td>true</td><td>if false - do not unregister/cancel delegation tokens from renewal, because same tokens may be used by spawned jobs</td></tr><tr><td>mapreduce.tasktracker.taskcontroller</td><td>org.apache.hadoop.mapred.DefaultTaskController</td><td>TaskController which is used to launch and manage task execution</td></tr><tr><td>mapreduce.tasktracker.group</td><td></td><td>Expert: Group to which TaskTracker belongs. If LinuxTaskController is configured via mapreduce.tasktracker.taskcontroller, the group owner of the task-controller binary should be same as this group.</td></tr><tr><td>mapreduce.shuffle.port</td><td>13562</td><td>Default port that the ShuffleHandler will run on. ShuffleHandler is a service run at the NodeManager to facilitate transfers of intermediate Map outputs to requesting Reducers.</td></tr><tr><td>mapreduce.job.reduce.shuffle.consumer.plugin.class</td><td>org.apache.hadoop.mapreduce.task.reduce.Shuffle</td><td>Name of the class whose instance will be used to send shuffle requests by reducetasks of this job. The class must be an instance of org.apache.hadoop.mapred.ShuffleConsumerPlugin.</td></tr><tr><td>mapreduce.tasktracker.healthchecker.script.path</td><td></td><td>Absolute path to the script which is periodicallyrun by the node health monitoring service to determine if the node is healthy or not. If the value of this key is empty or the file does not exist in the location configured here, the node health monitoring service is not started.</td></tr><tr><td>mapreduce.tasktracker.healthchecker.interval</td><td>60000</td><td>Frequency of the node health script to be run, in milliseconds</td></tr><tr><td>mapreduce.tasktracker.healthchecker.script.timeout</td><td>600000</td><td>Time after node health script should be killed if unresponsive and considered that the script has failed.</td></tr><tr><td>mapreduce.tasktracker.healthchecker.script.args</td><td></td><td>List of arguments which are to be passed to node health script when it is being launched comma seperated.</td></tr><tr><td>mapreduce.job.counters.limit</td><td>120</td><td>Limit on the number of user counters allowed per job.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL21hcHJlZHVjZS5mcmFtZXdvcmsubmFtZQ==">mapreduce.framework.name</span></td><td>local</td><td>The runtime framework for executing MapReduce jobs. Can be one of local, classic or yarn.</td></tr><tr><td>yarn.app.mapreduce.am.staging-dir</td><td>/tmp/hadoop-yarn/staging</td><td>The staging dir used while submitting jobs.</td></tr><tr><td>mapreduce.am.max-attempts</td><td>2</td><td>The maximum number of application attempts. It is a application-specific setting. It should not be larger than the global number set by resourcemanager. Otherwise, it will be override. The default number is set to 2, to allow at least one retry for AM.</td></tr><tr><td>mapreduce.job.end-notification.url</td><td></td><td>Indicates url which will be called on completion of job to inform end status of job. User can give at most 2 variables with URI : $jobId and $jobStatus. If they are present in URI, then they will be replaced by their respective values.</td></tr><tr><td>mapreduce.job.end-notification.retry.attempts</td><td>0</td><td>The number of times the submitter of the job wants to retry job end notification if it fails. This is capped by mapreduce.job.end-notification.max.attempts</td></tr><tr><td>mapreduce.job.end-notification.retry.interval</td><td>1000</td><td>The number of milliseconds the submitter of the job wants to wait before job end notification is retried if it fails. This is capped by mapreduce.job.end-notification.max.retry.interval</td></tr><tr><td>mapreduce.job.end-notification.max.attempts</td><td>5</td><td>The maximum number of times a URL will be read for providing job end notification. Cluster administrators can set this to limit how long after end of a job, the Application Master waits before exiting. Must be marked as final to prevent users from overriding this.</td></tr><tr><td>mapreduce.job.end-notification.max.retry.interval</td><td>5000</td><td>The maximum amount of time (in milliseconds) to wait before retrying job end notification. Cluster administrators can set this to limit how long the Application Master waits before exiting. Must be marked as final to prevent users from overriding this.</td></tr><tr><td>yarn.app.mapreduce.am.env</td><td></td><td>User added environment variables for the MR App Master processes. Example : 1) A=foo This will set the env variable A to foo 2) B=$B:c This is inherit tasktracker's B env variable.</td></tr><tr><td>yarn.app.mapreduce.am.admin.user.env</td><td></td><td>Environment variables for the MR App Master processes for admin purposes. These values are set first and can be overridden by the user env (yarn.app.mapreduce.am.env) Example : 1) A=foo This will set the env variable A to foo 2) B=$B:c This is inherit app master's B env variable.</td></tr><tr><td>yarn.app.mapreduce.am.command-opts</td><td>-Xmx1024m</td><td>Java opts for the MR App Master processes. The following symbol, if present, will be interpolated: @taskid@ is replaced by current TaskID. Any other occurrences of '@' will go unchanged. For example, to enable verbose gc logging to a file named for the taskid in /tmp and to set the heap maximum to be a gigabyte, pass a 'value' of: -Xmx1024m -verbose:gc -Xloggc:/tmp/@taskid@.gc Usage of -Djava.library.path can cause programs to no longer function if hadoop native libraries are used. These values should instead be set as part of LD_LIBRARY_PATH in the map / reduce JVM env using the mapreduce.map.env and mapreduce.reduce.env config settings.</td></tr><tr><td>yarn.app.mapreduce.am.admin-command-opts</td><td></td><td>Java opts for the MR App Master processes for admin purposes. It will appears before the opts set by yarn.app.mapreduce.am.command-opts and thus its options can be overridden user. Usage of -Djava.library.path can cause programs to no longer function if hadoop native libraries are used. These values should instead be set as part of LD_LIBRARY_PATH in the map / reduce JVM env using the mapreduce.map.env and mapreduce.reduce.env config settings.</td></tr><tr><td>yarn.app.mapreduce.am.job.task.listener.thread-count</td><td>30</td><td>The number of threads used to handle RPC calls in the MR AppMaster from remote tasks</td></tr><tr><td>yarn.app.mapreduce.am.job.client.port-range</td><td></td><td>Range of ports that the MapReduce AM can use when binding. Leave blank if you want all possible ports. For example 50000-50050,50100-50200</td></tr><tr><td>yarn.app.mapreduce.am.job.committer.cancel-timeout</td><td>60000</td><td>The amount of time in milliseconds to wait for the output committer to cancel an operation if the job is killed</td></tr><tr><td>yarn.app.mapreduce.am.job.committer.commit-window</td><td>10000</td><td>Defines a time window in milliseconds for output commit operations. If contact with the RM has occurred within this window then commits are allowed, otherwise the AM will not allow output commits until contact with the RM has been re-established.</td></tr><tr><td>yarn.app.mapreduce.am.scheduler.heartbeat.interval-ms</td><td>1000</td><td>The interval in ms at which the MR AppMaster should send heartbeats to the ResourceManager</td></tr><tr><td>yarn.app.mapreduce.client-am.ipc.max-retries</td><td>3</td><td>The number of client retries to the AM - before reconnecting to the RM to fetch Application Status.</td></tr><tr><td>yarn.app.mapreduce.client-am.ipc.max-retries-on-timeouts</td><td>3</td><td>The number of client retries on socket timeouts to the AM - before reconnecting to the RM to fetch Application Status.</td></tr><tr><td>yarn.app.mapreduce.client.max-retries</td><td>3</td><td>The number of client retries to the RM/HS before throwing exception. This is a layer above the ipc.</td></tr><tr><td>yarn.app.mapreduce.am.resource.mb</td><td>1536</td><td>The amount of memory the MR AppMaster needs.</td></tr><tr><td>yarn.app.mapreduce.am.resource.cpu-vcores</td><td>1</td><td>The number of virtual CPU cores the MR AppMaster needs.</td></tr><tr><td>mapreduce.application.classpath</td><td></td><td>CLASSPATH for MR applications. A comma-separated list of CLASSPATH entries. If mapreduce.application.framework is set then this must specify the appropriate classpath for that archive, and the name of the archive must be present in the classpath. If mapreduce.app-submission.cross-platform is false, platform-specific environment vairable expansion syntax would be used to construct the default CLASSPATH entries. For Linux: $HADOOP_MAPRED_HOME/share/hadoop/mapreduce/<em>, $HADOOP_MAPRED_HOME/share/hadoop/mapreduce/lib/</em>. For Windows: %HADOOP_MAPRED_HOME%/share/hadoop/mapreduce/<em>, %HADOOP_MAPRED_HOME%/share/hadoop/mapreduce/lib/</em>. If mapreduce.app-submission.cross-platform is true, platform-agnostic default CLASSPATH for MR applications would be used: /share/hadoop/mapreduce/<em>, /share/hadoop/mapreduce/lib/</em> Parameter expansion marker will be replaced by NodeManager on container launch based on the underlying OS accordingly.</td></tr><tr><td>mapreduce.app-submission.cross-platform</td><td>false</td><td>If enabled, user can submit an application cross-platform i.e. submit an application from a Windows client to a Linux/Unix server or vice versa.</td></tr><tr><td>mapreduce.application.framework.path</td><td></td><td>Path to the MapReduce framework archive. If set, the framework archive will automatically be distributed along with the job, and this path would normally reside in a public location in an HDFS filesystem. As with distributed cache files, this can be a URL with a fragment specifying the alias to use for the archive name. For example, hdfs:/mapred/framework/hadoop-mapreduce-2.1.1.tar.gz#mrframework would alias the localized archive as &quot;mrframework&quot;. Note that mapreduce.application.classpath must include the appropriate classpath for the specified framework. The base name of the archive, or alias of the archive if an alias is used, must appear in the specified classpath.</td></tr><tr><td>mapreduce.job.classloader</td><td>false</td><td>Whether to use a separate (isolated) classloader for user classes in the task JVM.</td></tr><tr><td>mapreduce.job.classloader.system.classes</td><td></td><td>Used to override the default definition of the system classes for the job classloader. The system classes are a comma-separated list of classes that should be loaded from the system classpath, not the user-supplied JARs, when mapreduce.job.classloader is enabled. Names ending in '.' (period) are treated as package names, and names starting with a '-' are treated as negative matches.</td></tr><tr><td>mapreduce.jobhistory.address</td><td>0.0.0.0:10020</td><td>MapReduce JobHistory Server IPC host:port</td></tr><tr><td>mapreduce.jobhistory.webapp.address</td><td>0.0.0.0:19888</td><td>MapReduce JobHistory Server Web UI host:port</td></tr><tr><td>mapreduce.jobhistory.keytab</td><td>/etc/security/keytab/jhs.service.keytab</td><td>Location of the kerberos keytab file for the MapReduce JobHistory Server.</td></tr><tr><td>mapreduce.jobhistory.principal</td><td>jhs/_HOST@REALM.TLD</td><td>Kerberos principal name for the MapReduce JobHistory Server.</td></tr><tr><td>mapreduce.jobhistory.intermediate-done-dir</td><td>${yarn.app.mapreduce.am.staging-dir}/history/done_intermediate</td><td></td></tr><tr><td>mapreduce.jobhistory.done-dir</td><td>${yarn.app.mapreduce.am.staging-dir}/history/done</td><td></td></tr><tr><td>mapreduce.jobhistory.cleaner.enable</td><td>true</td><td></td></tr><tr><td>mapreduce.jobhistory.cleaner.interval-ms</td><td>86400000</td><td>How often the job history cleaner checks for files to delete, in milliseconds. Defaults to 86400000 (one day). Files are only deleted if they are older than mapreduce.jobhistory.max-age-ms.</td></tr><tr><td>mapreduce.jobhistory.max-age-ms</td><td>604800000</td><td>Job history files older than this many milliseconds will be deleted when the history cleaner runs. Defaults to 604800000 (1 week).</td></tr><tr><td>mapreduce.jobhistory.client.thread-count</td><td>10</td><td>The number of threads to handle client API requests</td></tr><tr><td>mapreduce.jobhistory.datestring.cache.size</td><td>200000</td><td>Size of the date string cache. Effects the number of directories which will be scanned to find a job.</td></tr><tr><td>mapreduce.jobhistory.joblist.cache.size</td><td>20000</td><td>Size of the job list cache</td></tr><tr><td>mapreduce.jobhistory.loadedjobs.cache.size</td><td>5</td><td>Size of the loaded job cache. This property is ignored if the property mapreduce.jobhistory.loadedtasks.cache.size is set to a positive value.</td></tr><tr><td>mapreduce.jobhistory.loadedtasks.cache.size</td><td></td><td>Change the job history cache limit to be set in terms of total task count. If the total number of tasks loaded exceeds this value, then the job cache will be shrunk down until it is under this limit (minimum 1 job in cache). If this value is empty or nonpositive then the cache reverts to using the property mapreduce.jobhistory.loadedjobs.cache.size as a job cache size. Two recommendations for the mapreduce.jobhistory.loadedtasks.cache.size property: 1) For every 100k of cache size, set the heap size of the Job History Server to 1.2GB. For example, mapreduce.jobhistory.loadedtasks.cache.size=500000, heap size=6GB. 2) Make sure that the cache size is larger than the number of tasks required for the largest job run on the cluster. It might be a good idea to set the value slightly higher (say, 20%) in order to allow for job size growth.</td></tr><tr><td>mapreduce.jobhistory.move.interval-ms</td><td>180000</td><td>Scan for history files to more from intermediate done dir to done dir at this frequency.</td></tr><tr><td>mapreduce.jobhistory.move.thread-count</td><td>3</td><td>The number of threads used to move files.</td></tr><tr><td>mapreduce.jobhistory.store.class</td><td></td><td>The HistoryStorage class to use to cache history data.</td></tr><tr><td>mapreduce.jobhistory.minicluster.fixed.ports</td><td>false</td><td>Whether to use fixed ports with the minicluster</td></tr><tr><td>mapreduce.jobhistory.admin.address</td><td>0.0.0.0:10033</td><td>The address of the History server admin interface.</td></tr><tr><td>mapreduce.jobhistory.admin.acl</td><td>*</td><td>ACL of who can be admin of the History server.</td></tr><tr><td>mapreduce.jobhistory.recovery.enable</td><td>false</td><td>Enable the history server to store server state and recover server state upon startup. If enabled then mapreduce.jobhistory.recovery.store.class must be specified.</td></tr><tr><td>mapreduce.jobhistory.recovery.store.class</td><td>org.apache.hadoop.mapreduce.v2.hs.HistoryServerFileSystemStateStoreService</td><td>The HistoryServerStateStoreService class to store history server state for recovery.</td></tr><tr><td>mapreduce.jobhistory.recovery.store.fs.uri</td><td>${hadoop.tmp.dir}/mapred/history/recoverystore</td><td>The URI where history server state will be stored if HistoryServerFileSystemStateStoreService is configured as the recovery storage class.</td></tr><tr><td>mapreduce.jobhistory.http.policy</td><td>HTTP_ONLY</td><td>This configures the HTTP endpoint for JobHistoryServer web UI. The following values are supported: - HTTP_ONLY : Service is provided only on http - HTTPS_ONLY : Service is provided only on https</td></tr></tbody></table><p>yarn-site.xml</p><table><thead><tr><th>name</th><th>value</th><th>description</th></tr></thead><tbody><tr><td>yarn.ipc.client.factory.class</td><td></td><td>Factory to create client IPC classes.</td></tr><tr><td>yarn.ipc.server.factory.class</td><td></td><td>Factory to create server IPC classes.</td></tr><tr><td>yarn.ipc.record.factory.class</td><td></td><td>Factory to create serializeable records.</td></tr><tr><td>yarn.ipc.rpc.class</td><td>org.apache.hadoop.yarn.ipc.HadoopYarnProtoRPC</td><td>RPC class implementation</td></tr><tr><td>yarn.resourcemanager.hostname</td><td>0.0.0.0</td><td>The hostname of the RM.</td></tr><tr><td>yarn.resourcemanager.address</td><td>${yarn.resourcemanager.hostname}:8032</td><td>The address of the applications manager interface in the RM.</td></tr><tr><td>yarn.resourcemanager.bind-host</td><td></td><td>The actual address the server will bind to. If this optional address is set, the RPC and webapp servers will bind to this address and the port specified in yarn.resourcemanager.address and yarn.resourcemanager.webapp.address, respectively. This is most useful for making RM listen to all interfaces by setting to 0.0.0.0.</td></tr><tr><td>yarn.resourcemanager.client.thread-count</td><td>50</td><td>The number of threads used to handle applications manager requests.</td></tr><tr><td>yarn.dispatcher.drain-events.timeout</td><td>300000</td><td>Timeout in milliseconds when YARN dispatcher tries to drain the events. Typically, this happens when service is stopping. e.g. RM drains the ATS events dispatcher when stopping.</td></tr><tr><td>yarn.am.liveness-monitor.expiry-interval-ms</td><td>600000</td><td>The expiry interval for application master reporting.</td></tr><tr><td>yarn.resourcemanager.principal</td><td></td><td>The Kerberos principal for the resource manager.</td></tr><tr><td>yarn.resourcemanager.scheduler.address</td><td>${yarn.resourcemanager.hostname}:8030</td><td>The address of the scheduler interface.</td></tr><tr><td>yarn.resourcemanager.scheduler.client.thread-count</td><td>50</td><td>Number of threads to handle scheduler interface.</td></tr><tr><td>yarn.http.policy</td><td>HTTP_ONLY</td><td>This configures the HTTP endpoint for Yarn Daemons.The following values are supported: - HTTP_ONLY : Service is provided only on http - HTTPS_ONLY : Service is provided only on https</td></tr><tr><td>yarn.resourcemanager.webapp.address</td><td>${yarn.resourcemanager.hostname}:8088</td><td>The http address of the RM web application.</td></tr><tr><td>yarn.resourcemanager.webapp.https.address</td><td>${yarn.resourcemanager.hostname}:8090</td><td>The https adddress of the RM web application.</td></tr><tr><td>yarn.resourcemanager.resource-tracker.address</td><td>${yarn.resourcemanager.hostname}:8031</td><td></td></tr><tr><td>yarn.acl.enable</td><td>false</td><td>Are acls enabled.</td></tr><tr><td>yarn.admin.acl</td><td>*</td><td>ACL of who can be admin of the YARN cluster.</td></tr><tr><td>yarn.resourcemanager.admin.address</td><td>${yarn.resourcemanager.hostname}:8033</td><td>The address of the RM admin interface.</td></tr><tr><td>yarn.resourcemanager.admin.client.thread-count</td><td>1</td><td>Number of threads used to handle RM admin interface.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL3lhcm4ucmVzb3VyY2VtYW5hZ2VyLmNvbm5lY3QubWF4LXdhaXQubXM=">yarn.resourcemanager.connect.max-wait.ms</span></td><td>900000</td><td>Maximum time to wait to establish connection to ResourceManager.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL3lhcm4ucmVzb3VyY2VtYW5hZ2VyLmNvbm5lY3QucmV0cnktaW50ZXJ2YWwubXM=">yarn.resourcemanager.connect.retry-interval.ms</span></td><td>30000</td><td>How often to try connecting to the ResourceManager.</td></tr><tr><td>yarn.resourcemanager.am.max-attempts</td><td>2</td><td>The maximum number of application attempts. It's a global setting for all application masters. Each application master can specify its individual maximum number of application attempts via the API, but the individual number cannot be more than the global upper bound. If it is, the resourcemanager will override it. The default number is set to 2, to allow at least one retry for AM.</td></tr><tr><td>yarn.resourcemanager.container.liveness-monitor.interval-ms</td><td>600000</td><td>How often to check that containers are still alive.</td></tr><tr><td>yarn.resourcemanager.keytab</td><td>/etc/krb5.keytab</td><td>The keytab for the resource manager.</td></tr><tr><td>yarn.resourcemanager.webapp.delegation-token-auth-filter.enabled</td><td>true</td><td>Flag to enable override of the default kerberos authentication filter with the RM authentication filter to allow authentication using delegation tokens(fallback to kerberos if the tokens are missing). Only applicable when the http authentication type is kerberos.</td></tr><tr><td>yarn.nm.liveness-monitor.expiry-interval-ms</td><td>600000</td><td>How long to wait until a node manager is considered dead.</td></tr><tr><td>yarn.resourcemanager.nodes.include-path</td><td></td><td>Path to file with nodes to include.</td></tr><tr><td>yarn.resourcemanager.nodes.exclude-path</td><td></td><td>Path to file with nodes to exclude.</td></tr><tr><td>yarn.resourcemanager.resource-tracker.client.thread-count</td><td>50</td><td>Number of threads to handle resource tracker calls.</td></tr><tr><td>yarn.resourcemanager.scheduler.class</td><td>org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.CapacityScheduler</td><td>The class to use as the resource scheduler.</td></tr><tr><td>yarn.scheduler.minimum-allocation-mb</td><td>1024</td><td>The minimum allocation for every container request at the RM, in MBs. Memory requests lower than this won't take effect, and the specified value will get allocated at minimum.</td></tr><tr><td>yarn.scheduler.maximum-allocation-mb</td><td>8192</td><td>The maximum allocation for every container request at the RM, in MBs. Memory requests higher than this won't take effect, and will get capped to this value.</td></tr><tr><td>yarn.scheduler.minimum-allocation-vcores</td><td>1</td><td>The minimum allocation for every container request at the RM, in terms of virtual CPU cores. Requests lower than this won't take effect, and the specified value will get allocated the minimum.</td></tr><tr><td>yarn.scheduler.maximum-allocation-vcores</td><td>32</td><td>The maximum allocation for every container request at the RM, in terms of virtual CPU cores. Requests higher than this won't take effect, and will get capped to this value.</td></tr><tr><td>yarn.resourcemanager.recovery.enabled</td><td>false</td><td>Enable RM to recover state after starting. If true, then yarn.resourcemanager.store.class must be specified.</td></tr><tr><td>yarn.resourcemanager.fail-fast</td><td yarn.fail-fast="">$</td><td>Should RM fail fast if it encounters any errors. By defalt, it points to ${yarn.fail-fast}. Errors include: 1) exceptions when state-store write/read operations fails.</td></tr><tr><td>yarn.fail-fast</td><td>false</td><td>Should YARN fail fast if it encounters any errors. This is a global config for all other components including RM,NM etc. If no value is set for component-specific config (e.g yarn.resourcemanager.fail-fast), this value will be the default.</td></tr><tr><td>yarn.resourcemanager.work-preserving-recovery.enabled</td><td>false</td><td>Enable RM work preserving recovery. This configuration is private to YARN for experimenting the feature.</td></tr><tr><td>yarn.resourcemanager.work-preserving-recovery.scheduling-wait-ms</td><td>10000</td><td>Set the amount of time RM waits before allocating new containers on work-preserving-recovery. Such wait period gives RM a chance to settle down resyncing with NMs in the cluster on recovery, before assigning new containers to applications.</td></tr><tr><td>yarn.resourcemanager.store.class</td><td>org.apache.hadoop.yarn.server.resourcemanager.recovery.FileSystemRMStateStore</td><td>The class to use as the persistent store. If org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore is used, the store is implicitly fenced; meaning a single ResourceManager is able to use the store at any point in time. More details on this implicit fencing, along with setting up appropriate ACLs is discussed under yarn.resourcemanager.zk-state-store.root-node.acl.</td></tr><tr><td>yarn.resourcemanager.state-store.max-completed-applications</td><td yarn.resourcemanager.max-completed-applications="">$</td><td>The maximum number of completed applications RM state store keeps, less than or equals to ${yarn.resourcemanager.max-completed-applications}. By default, it equals to ${yarn.resourcemanager.max-completed-applications}. This ensures that the applications kept in the state store are consistent with the applications remembered in RM memory. Any values larger than ${yarn.resourcemanager.max-completed-applications} will be reset to ${yarn.resourcemanager.max-completed-applications}. Note that this value impacts the RM recovery performance.Typically, a smaller value indicates better performance on RM recovery.</td></tr><tr><td>yarn.resourcemanager.zk-address</td><td></td><td>Host:Port of the ZooKeeper server to be used by the RM. This must be supplied when using the ZooKeeper based implementation of the RM state store and/or embedded automatic failover in a HA setting.</td></tr><tr><td>yarn.resourcemanager.zk-num-retries</td><td>1000</td><td>Number of times RM tries to connect to ZooKeeper.</td></tr><tr><td>yarn.resourcemanager.zk-retry-interval-ms</td><td>1000</td><td>Retry interval in milliseconds when connecting to ZooKeeper. When HA is enabled, the value here is NOT used. It is generated automatically from yarn.resourcemanager.zk-timeout-ms and yarn.resourcemanager.zk-num-retries.</td></tr><tr><td>yarn.resourcemanager.zk-state-store.parent-path</td><td>/rmstore</td><td>Full path of the ZooKeeper znode where RM state will be stored. This must be supplied when using org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore as the value for yarn.resourcemanager.store.class</td></tr><tr><td>yarn.resourcemanager.zk-timeout-ms</td><td>10000</td><td>ZooKeeper session timeout in milliseconds. Session expiration is managed by the ZooKeeper cluster itself, not by the client. This value is used by the cluster to determine when the client's session expires. Expirations happens when the cluster does not hear from the client within the specified session timeout period (i.e. no heartbeat).</td></tr><tr><td>yarn.resourcemanager.zk-acl</td><td>world:anyone:rwcda</td><td>ACL's to be used for ZooKeeper znodes.</td></tr><tr><td>yarn.resourcemanager.zk-state-store.root-node.acl</td><td></td><td>ACLs to be used for the root znode when using ZKRMStateStore in a HA scenario for fencing. ZKRMStateStore supports implicit fencing to allow a single ResourceManager write-access to the store. For fencing, the ResourceManagers in the cluster share read-write-admin privileges on the root node, but the Active ResourceManager claims exclusive create-delete permissions. By default, when this property is not set, we use the ACLs from yarn.resourcemanager.zk-acl for shared admin access and rm-address:random-number for username-based exclusive create-delete access. This property allows users to set ACLs of their choice instead of using the default mechanism. For fencing to work, the ACLs should be carefully set differently on each ResourceManger such that all the ResourceManagers have shared admin access and the Active ResourceManger takes over (exclusively) the create-delete access.</td></tr><tr><td>yarn.resourcemanager.zk-auth</td><td></td><td>Specify the auths to be used for the ACL's specified in both the yarn.resourcemanager.zk-acl and yarn.resourcemanager.zk-state-store.root-node.acl properties. This takes a comma-separated list of authentication mechanisms, each of the form 'scheme:auth' (the same syntax used for the 'addAuth' command in the ZK CLI).</td></tr><tr><td>yarn.resourcemanager.fs.state-store.uri</td><td>${hadoop.tmp.dir}/yarn/system/rmstore</td><td>URI pointing to the location of the FileSystem path where RM state will be stored. This must be supplied when using org.apache.hadoop.yarn.server.resourcemanager.recovery.FileSystemRMStateStore as the value for yarn.resourcemanager.store.class</td></tr><tr><td>yarn.resourcemanager.fs.state-store.retry-policy-spec</td><td>2000, 500</td><td>hdfs client retry policy specification. hdfs client retry is always enabled. Specified in pairs of sleep-time and number-of-retries and (t0, n0), (t1, n1), ..., the first n0 retries sleep t0 milliseconds on average, the following n1 retries sleep t1 milliseconds on average, and so on.</td></tr><tr><td>yarn.resourcemanager.ha.enabled</td><td>false</td><td>Enable RM high-availability. When enabled, (1) The RM starts in the Standby mode by default, and transitions to the Active mode when prompted to. (2) The nodes in the RM ensemble are listed in yarn.resourcemanager.ha.rm-ids (3) The id of each RM either comes from <span class="exturl" data-url="aHR0cDovL3lhcm4ucmVzb3VyY2VtYW5hZ2VyLmhhLmlk">yarn.resourcemanager.ha.id</span> if <span class="exturl" data-url="aHR0cDovL3lhcm4ucmVzb3VyY2VtYW5hZ2VyLmhhLmlk">yarn.resourcemanager.ha.id</span> is explicitly specified or can be figured out by matching yarn.resourcemanager.address.{id} with local address (4) The actual physical addresses come from the configs of the pattern - {rpc-config}.</td></tr><tr><td>yarn.resourcemanager.ha.automatic-failover.enabled</td><td>true</td><td>Enable automatic failover. By default, it is enabled only when HA is enabled</td></tr><tr><td>yarn.resourcemanager.ha.automatic-failover.embedded</td><td>true</td><td>Enable embedded automatic failover. By default, it is enabled only when HA is enabled. The embedded elector relies on the RM state store to handle fencing, and is primarily intended to be used in conjunction with ZKRMStateStore.</td></tr><tr><td>yarn.resourcemanager.ha.automatic-failover.zk-base-path</td><td>/yarn-leader-election</td><td>The base znode path to use for storing leader information, when using ZooKeeper based leader election.</td></tr><tr><td>yarn.resourcemanager.cluster-id</td><td></td><td>Name of the cluster. In a HA setting, this is used to ensure the RM participates in leader election for this cluster and ensures it does not affect other clusters</td></tr><tr><td>yarn.resourcemanager.ha.rm-ids</td><td></td><td>The list of RM nodes in the cluster when HA is enabled. See description of yarn.resourcemanager.ha .enabled for full details on how this is used.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL3lhcm4ucmVzb3VyY2VtYW5hZ2VyLmhhLmlk">yarn.resourcemanager.ha.id</span></td><td></td><td>The id (string) of the current RM. When HA is enabled, this is an optional config. The id of current RM can be set by explicitly specifying <span class="exturl" data-url="aHR0cDovL3lhcm4ucmVzb3VyY2VtYW5hZ2VyLmhhLmlk">yarn.resourcemanager.ha.id</span> or figured out by matching yarn.resourcemanager.address.{id} with local address See description of yarn.resourcemanager.ha.enabled for full details on how this is used.</td></tr><tr><td>yarn.client.failover-proxy-provider</td><td>org.apache.hadoop.yarn.client.ConfiguredRMFailoverProxyProvider</td><td>When HA is enabled, the class to be used by Clients, AMs and NMs to failover to the Active RM. It should extend org.apache.hadoop.yarn.client.RMFailoverProxyProvider</td></tr><tr><td>yarn.client.failover-max-attempts</td><td></td><td>When HA is enabled, the max number of times FailoverProxyProvider should attempt failover. When set, this overrides the <span class="exturl" data-url="aHR0cDovL3lhcm4ucmVzb3VyY2VtYW5hZ2VyLmNvbm5lY3QubWF4LXdhaXQubXM=">yarn.resourcemanager.connect.max-wait.ms</span>. When not set, this is inferred from <span class="exturl" data-url="aHR0cDovL3lhcm4ucmVzb3VyY2VtYW5hZ2VyLmNvbm5lY3QubWF4LXdhaXQubXM=">yarn.resourcemanager.connect.max-wait.ms</span>.</td></tr><tr><td>yarn.client.failover-sleep-base-ms</td><td></td><td>When HA is enabled, the sleep base (in milliseconds) to be used for calculating the exponential delay between failovers. When set, this overrides the yarn.resourcemanager.connect.* settings. When not set, <span class="exturl" data-url="aHR0cDovL3lhcm4ucmVzb3VyY2VtYW5hZ2VyLmNvbm5lY3QucmV0cnktaW50ZXJ2YWwubXM=">yarn.resourcemanager.connect.retry-interval.ms</span> is used instead.</td></tr><tr><td>yarn.client.failover-sleep-max-ms</td><td></td><td>When HA is enabled, the maximum sleep time (in milliseconds) between failovers. When set, this overrides the yarn.resourcemanager.connect.* settings. When not set, <span class="exturl" data-url="aHR0cDovL3lhcm4ucmVzb3VyY2VtYW5hZ2VyLmNvbm5lY3QucmV0cnktaW50ZXJ2YWwubXM=">yarn.resourcemanager.connect.retry-interval.ms</span> is used instead.</td></tr><tr><td>yarn.client.failover-retries</td><td>0</td><td>When HA is enabled, the number of retries per attempt to connect to a ResourceManager. In other words, it is the ipc.client.connect.max.retries to be used during failover attempts</td></tr><tr><td>yarn.client.failover-retries-on-socket-timeouts</td><td>0</td><td>When HA is enabled, the number of retries per attempt to connect to a ResourceManager on socket timeouts. In other words, it is the ipc.client.connect.max.retries.on.timeouts to be used during failover attempts</td></tr><tr><td>yarn.resourcemanager.max-completed-applications</td><td>10000</td><td>The maximum number of completed applications RM keeps.</td></tr><tr><td>yarn.resourcemanager.delayed.delegation-token.removal-interval-ms</td><td>30000</td><td>Interval at which the delayed token removal thread runs</td></tr><tr><td>yarn.resourcemanager.proxy-user-privileges.enabled</td><td>false</td><td>If true, ResourceManager will have proxy-user privileges. Use case: In a secure cluster, YARN requires the user hdfs delegation-tokens to do localization and log-aggregation on behalf of the user. If this is set to true, ResourceManager is able to request new hdfs delegation tokens on behalf of the user. This is needed by long-running-service, because the hdfs tokens will eventually expire and YARN requires new valid tokens to do localization and log-aggregation. Note that to enable this use case, the corresponding HDFS NameNode has to configure ResourceManager as the proxy-user so that ResourceManager can itself ask for new tokens on behalf of the user when tokens are past their max-life-time.</td></tr><tr><td>yarn.resourcemanager.am-rm-tokens.master-key-rolling-interval-secs</td><td>86400</td><td>Interval for the roll over for the master key used to generate application tokens</td></tr><tr><td>yarn.resourcemanager.container-tokens.master-key-rolling-interval-secs</td><td>86400</td><td>Interval for the roll over for the master key used to generate container tokens. It is expected to be much greater than yarn.nm.liveness-monitor.expiry-interval-ms and yarn.rm.container-allocation.expiry-interval-ms. Otherwise the behavior is undefined.</td></tr><tr><td>yarn.resourcemanager.nodemanagers.heartbeat-interval-ms</td><td>1000</td><td>The heart-beat interval in milliseconds for every NodeManager in the cluster.</td></tr><tr><td>yarn.resourcemanager.nodemanager.minimum.version</td><td>NONE</td><td>The minimum allowed version of a connecting nodemanager. The valid values are NONE (no version checking), EqualToRM (the nodemanager's version is equal to or greater than the RM version), or a Version String.</td></tr><tr><td>yarn.resourcemanager.scheduler.monitor.enable</td><td>false</td><td>Enable a set of periodic monitors (specified in yarn.resourcemanager.scheduler.monitor.policies) that affect the scheduler.</td></tr><tr><td>yarn.resourcemanager.scheduler.monitor.policies</td><td>org.apache.hadoop.yarn.server.resourcemanager.monitor.capacity.ProportionalCapacityPreemptionPolicy</td><td>The list of SchedulingEditPolicy classes that interact with the scheduler. A particular module may be incompatible with the scheduler, other policies, or a configuration of either.</td></tr><tr><td>yarn.resourcemanager.configuration.provider-class</td><td>org.apache.hadoop.yarn.LocalConfigurationProvider</td><td>The class to use as the configuration provider. If org.apache.hadoop.yarn.LocalConfigurationProvider is used, the local configuration will be loaded. If org.apache.hadoop.yarn.FileSystemBasedConfigurationProvider is used, the configuration which will be loaded should be uploaded to remote File system first.</td></tr><tr><td>yarn.resourcemanager.system-metrics-publisher.enabled</td><td>false</td><td>The setting that controls whether yarn system metrics is published on the timeline server or not by RM.</td></tr><tr><td>yarn.resourcemanager.system-metrics-publisher.dispatcher.pool-size</td><td>10</td><td>Number of worker threads that send the yarn system metrics data.</td></tr><tr><td>yarn.nodemanager.hostname</td><td>0.0.0.0</td><td>The hostname of the NM.</td></tr><tr><td>yarn.nodemanager.address</td><td>${yarn.nodemanager.hostname}:0</td><td>The address of the container manager in the NM.</td></tr><tr><td>yarn.nodemanager.bind-host</td><td></td><td>The actual address the server will bind to. If this optional address is set, the RPC and webapp servers will bind to this address and the port specified in yarn.nodemanager.address and yarn.nodemanager.webapp.address, respectively. This is most useful for making NM listen to all interfaces by setting to 0.0.0.0.</td></tr><tr><td>yarn.nodemanager.admin-env</td><td>MALLOC_ARENA_MAX=$MALLOC_ARENA_MAX</td><td>Environment variables that should be forwarded from the NodeManager's environment to the container's.</td></tr><tr><td>yarn.nodemanager.env-whitelist</td><td>JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,HADOOP_YARN_HOME</td><td>Environment variables that containers may override rather than use NodeManager's default.</td></tr><tr><td>yarn.nodemanager.container-executor.class</td><td>org.apache.hadoop.yarn.server.nodemanager.DefaultContainerExecutor</td><td>who will execute(launch) the containers.</td></tr><tr><td>yarn.nodemanager.container-manager.thread-count</td><td>20</td><td>Number of threads container manager uses.</td></tr><tr><td>yarn.nodemanager.delete.thread-count</td><td>4</td><td>Number of threads used in cleanup.</td></tr><tr><td>yarn.nodemanager.delete.debug-delay-sec</td><td>0</td><td>Number of seconds after an application finishes before the nodemanager's DeletionService will delete the application's localized file directory and log directory. To diagnose Yarn application problems, set this property's value large enough (for example, to 600 = 10 minutes) to permit examination of these directories. After changing the property's value, you must restart the nodemanager in order for it to have an effect. The roots of Yarn applications' work directories is configurable with the yarn.nodemanager.local-dirs property (see below), and the roots of the Yarn applications' log directories is configurable with the yarn.nodemanager.log-dirs property (see also below).</td></tr><tr><td>yarn.nodemanager.keytab</td><td>/etc/krb5.keytab</td><td>Keytab for NM.</td></tr><tr><td>yarn.nodemanager.local-dirs</td><td>${hadoop.tmp.dir}/nm-local-dir</td><td>List of directories to store localized files in. An application's localized file directory will be found in: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>y</mi><mi>a</mi><mi>r</mi><mi>n</mi><mi mathvariant="normal">.</mi><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>m</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>l</mi><mo>−</mo><mi>d</mi><mi>i</mi><mi>r</mi><mi>s</mi></mrow><mi mathvariant="normal">/</mi><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>c</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">{yarn.nodemanager.local-dirs}/usercache/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">n</span><span class="mord">.</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">s</span></span><span class="mord">/</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord">/</span></span></span></span>{user}/appcache/application_{appid}. Individual containers' work directories, called container_{contid}, will be subdirectories of this.</td></tr><tr><td>yarn.nodemanager.local-cache.max-files-per-directory</td><td>8192</td><td>It limits the maximum number of files which will be localized in a single local directory. If the limit is reached then sub-directories will be created and new files will be localized in them. If it is set to a value less than or equal to 36 [which are sub-directories (0-9 and then a-z)] then NodeManager will fail to start. For example; [for public cache] if this is configured with a value of 40 ( 4 files + 36 sub-directories) and the local-dir is &quot;/tmp/local-dir1&quot; then it will allow 4 files to be created directly inside &quot;/tmp/local-dir1/filecache&quot;. For files that are localized further it will create a sub-directory &quot;0&quot; inside &quot;/tmp/local-dir1/filecache&quot; and will localize files inside it until it becomes full. If a file is removed from a sub-directory that is marked full, then that sub-directory will be used back again to localize files.</td></tr><tr><td>yarn.nodemanager.localizer.address</td><td>${yarn.nodemanager.hostname}:8040</td><td>Address where the localizer IPC is.</td></tr><tr><td>yarn.nodemanager.localizer.cache.cleanup.interval-ms</td><td>600000</td><td>Interval in between cache cleanups.</td></tr><tr><td>yarn.nodemanager.localizer.cache.target-size-mb</td><td>10240</td><td>Target size of localizer cache in MB, per nodemanager. It is a target retention size that only includes resources with PUBLIC and PRIVATE visibility and excludes resources with APPLICATION visibility</td></tr><tr><td>yarn.nodemanager.localizer.client.thread-count</td><td>5</td><td>Number of threads to handle localization requests.</td></tr><tr><td>yarn.nodemanager.localizer.fetch.thread-count</td><td>4</td><td>Number of threads to use for localization fetching.</td></tr><tr><td>yarn.nodemanager.log-dirs</td><td>${yarn.log.dir}/userlogs</td><td>Where to store container logs. An application's localized log directory will be found in {yarn.nodemanager.log-dirs}/application_{appid}. Individual containers' log directories will be below this, in directories named container_{$contid}. Each container directory will contain the files stderr, stdin, and syslog generated by that container.</td></tr><tr><td>yarn.log-aggregation-enable</td><td>false</td><td>Whether to enable log aggregation. Log aggregation collects each container's logs and moves these logs onto a file-system, for e.g. HDFS, after the application completes. Users can configure the &quot;yarn.nodemanager.remote-app-log-dir&quot; and &quot;yarn.nodemanager.remote-app-log-dir-suffix&quot; properties to determine where these logs are moved to. Users can access the logs via the Application Timeline Server.</td></tr><tr><td>yarn.log-aggregation.retain-seconds</td><td>-1</td><td>How long to keep aggregation logs before deleting them. -1 disables. Be careful set this too small and you will spam the name node.</td></tr><tr><td>yarn.log-aggregation.retain-check-interval-seconds</td><td>-1</td><td>How long to wait between aggregated log retention checks. If set to 0 or a negative value then the value is computed as one-tenth of the aggregated log retention time. Be careful set this too small and you will spam the name node.</td></tr><tr><td>yarn.nodemanager.log.retain-seconds</td><td>10800</td><td>Time in seconds to retain user logs. Only applicable if log aggregation is disabled</td></tr><tr><td>yarn.nodemanager.remote-app-log-dir</td><td>/tmp/logs</td><td>Where to aggregate logs to.</td></tr><tr thisparam=""><td>yarn.nodemanager.remote-app-log-dir-suffix</td><td>logs</td><td>The remote log dir will be created at {yarn.nodemanager.remote-app-log-dir}/${user}/</td></tr><tr><td>yarn.nodemanager.resource.memory-mb</td><td>8192</td><td>Amount of physical memory, in MB, that can be allocated for containers.</td></tr><tr><td>yarn.nodemanager.pmem-check-enabled</td><td>true</td><td>Whether physical memory limits will be enforced for containers.</td></tr><tr><td>yarn.nodemanager.vmem-check-enabled</td><td>true</td><td>Whether virtual memory limits will be enforced for containers.</td></tr><tr><td>yarn.nodemanager.vmem-pmem-ratio</td><td>2.1</td><td>Ratio between virtual memory to physical memory when setting memory limits for containers. Container allocations are expressed in terms of physical memory, and virtual memory usage is allowed to exceed this allocation by this ratio.</td></tr><tr><td>yarn.nodemanager.resource.cpu-vcores</td><td>8</td><td>Number of vcores that can be allocated for containers. This is used by the RM scheduler when allocating resources for containers. This is not used to limit the number of physical cores used by YARN containers.</td></tr><tr><td>yarn.nodemanager.resource.percentage-physical-cpu-limit</td><td>100</td><td>Percentage of CPU that can be allocated for containers. This setting allows users to limit the amount of CPU that YARN containers use. Currently functional only on Linux using cgroups. The default is to use 100% of CPU.</td></tr><tr><td>yarn.nodemanager.webapp.address</td><td>${yarn.nodemanager.hostname}:8042</td><td>NM Webapp address.</td></tr><tr><td>yarn.nodemanager.container-monitor.interval-ms</td><td>3000</td><td>How often to monitor containers.</td></tr><tr><td>yarn.nodemanager.container-monitor.resource-calculator.class</td><td></td><td>Class that calculates containers current resource utilization.</td></tr><tr><td>yarn.nodemanager.health-checker.interval-ms</td><td>600000</td><td>Frequency of running node health script.</td></tr><tr><td>yarn.nodemanager.health-checker.script.timeout-ms</td><td>1200000</td><td>Script time out period.</td></tr><tr><td>yarn.nodemanager.health-checker.script.path</td><td></td><td>The health check script to run.</td></tr><tr><td>yarn.nodemanager.health-checker.script.opts</td><td></td><td>The arguments to pass to the health check script.</td></tr><tr><td>yarn.nodemanager.disk-health-checker.interval-ms</td><td>120000</td><td>Frequency of running disk health checker code.</td></tr><tr><td>yarn.nodemanager.disk-health-checker.min-healthy-disks</td><td>0.25</td><td>The minimum fraction of number of disks to be healthy for the nodemanager to launch new containers. This correspond to both yarn.nodemanager.local-dirs and yarn.nodemanager.log-dirs. i.e. If there are less number of healthy local-dirs (or log-dirs) available, then new containers will not be launched on this node.</td></tr><tr><td>yarn.nodemanager.disk-health-checker.max-disk-utilization-per-disk-percentage</td><td>90.0</td><td>The maximum percentage of disk space utilization allowed after which a disk is marked as bad. Values can range from 0.0 to 100.0. If the value is greater than or equal to 100, the nodemanager will check for full disk. This applies to yarn.nodemanager.local-dirs and yarn.nodemanager.log-dirs.</td></tr><tr><td>yarn.nodemanager.disk-health-checker.min-free-space-per-disk-mb</td><td>0</td><td>The minimum space that must be available on a disk for it to be used. This applies to yarn.nodemanager.local-dirs and yarn.nodemanager.log-dirs.</td></tr><tr><td>yarn.nodemanager.linux-container-executor.path</td><td></td><td>The path to the Linux container executor.</td></tr><tr><td>yarn.nodemanager.linux-container-executor.resources-handler.class</td><td>org.apache.hadoop.yarn.server.nodemanager.util.DefaultLCEResourcesHandler</td><td>The class which should help the LCE handle resources.</td></tr><tr><td>yarn.nodemanager.linux-container-executor.cgroups.hierarchy</td><td>/hadoop-yarn</td><td>The cgroups hierarchy under which to place YARN proccesses (cannot contain commas). If yarn.nodemanager.linux-container-executor.cgroups.mount is false (that is, if cgroups have been pre-configured), then this cgroups hierarchy must already exist and be writable by the NodeManager user, otherwise the NodeManager may fail. Only used when the LCE resources handler is set to the CgroupsLCEResourcesHandler.</td></tr><tr><td>yarn.nodemanager.linux-container-executor.cgroups.mount</td><td>false</td><td>Whether the LCE should attempt to mount cgroups if not found. Only used when the LCE resources handler is set to the CgroupsLCEResourcesHandler.</td></tr><tr><td>yarn.nodemanager.linux-container-executor.cgroups.mount-path</td><td></td><td>Where the LCE should attempt to mount cgroups if not found. Common locations include /sys/fs/cgroup and /cgroup; the default location can vary depending on the Linux distribution in use. This path must exist before the NodeManager is launched. Only used when the LCE resources handler is set to the CgroupsLCEResourcesHandler, and yarn.nodemanager.linux-container-executor.cgroups.mount is true.</td></tr><tr><td>yarn.nodemanager.linux-container-executor.nonsecure-mode.limit-users</td><td>true</td><td>This determines which of the two modes that LCE should use on a non-secure cluster. If this value is set to true, then all containers will be launched as the user specified in yarn.nodemanager.linux-container-executor.nonsecure-mode.local-user. If this value is set to false, then containers will run as the user who submitted the application.</td></tr><tr><td>yarn.nodemanager.linux-container-executor.nonsecure-mode.local-user</td><td>nobody</td><td>The UNIX user that containers will run as when Linux-container-executor is used in nonsecure mode (a use case for this is using cgroups) if the yarn.nodemanager.linux-container-executor.nonsecure-mode.limit-users is set to true.</td></tr><tr><td>yarn.nodemanager.linux-container-executor.nonsecure-mode.user-pattern</td><td><span>-@_.A-Za-z0-9</span><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup><span 0,255="">-@_.A-Za-z0-9</span>?[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">]</mo><mo stretchy="false">?</mo></mrow><annotation encoding="application/x-tex">]?</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mclose">]</span><span class="mclose">?</span></span></span></span></td><td>The allowed pattern for UNIX user names enforced by Linux-container-executor when used in nonsecure mode (use case for this is using cgroups). The default value is taken from /usr/sbin/adduser</td></tr><tr><td>yarn.nodemanager.linux-container-executor.cgroups.strict-resource-usage</td><td>false</td><td>This flag determines whether apps should run with strict resource limits or be allowed to consume spare resources if they need them. For example, turning the flag on will restrict apps to use only their share of CPU, even if the node has spare CPU cycles. The default value is false i.e. use available resources. Please note that turning this flag on may reduce job throughput on the cluster.</td></tr><tr><td>yarn.nodemanager.log-aggregation.compression-type</td><td>none</td><td>T-file compression types used to compress aggregated logs.</td></tr><tr><td>yarn.nodemanager.principal</td><td></td><td>The kerberos principal for the node manager.</td></tr><tr><td>yarn.nodemanager.aux-services</td><td></td><td>the valid service name should only contain a-zA-Z0-9_ and can not start with numbers</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL3lhcm4ubm9kZW1hbmFnZXIuc2xlZXAtZGVsYXktYmVmb3JlLXNpZ2tpbGwubXM=">yarn.nodemanager.sleep-delay-before-sigkill.ms</span></td><td>250</td><td>No. of ms to wait between sending a SIGTERM and SIGKILL to a container</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL3lhcm4ubm9kZW1hbmFnZXIucHJvY2Vzcy1raWxsLXdhaXQubXM=">yarn.nodemanager.process-kill-wait.ms</span></td><td>2000</td><td>Max time to wait for a process to come up when trying to cleanup a container</td></tr><tr><td>yarn.nodemanager.resourcemanager.minimum.version</td><td>NONE</td><td>The minimum allowed version of a resourcemanager that a nodemanager will connect to. The valid values are NONE (no version checking), EqualToNM (the resourcemanager's version is equal to or greater than the NM version), or a Version String.</td></tr><tr><td>yarn.client.nodemanager-client-async.thread-pool-max-size</td><td>500</td><td>Max number of threads in NMClientAsync to process container management events</td></tr><tr><td>yarn.client.nodemanager-connect.max-wait-ms</td><td>180000</td><td>Max time to wait to establish a connection to NM</td></tr><tr><td>yarn.client.nodemanager-connect.retry-interval-ms</td><td>10000</td><td>Time interval between each attempt to connect to NM</td></tr><tr><td>yarn.client.max-cached-nodemanagers-proxies</td><td>0</td><td>Maximum number of proxy connections to cache for node managers. If set to a value greater than zero then the cache is enabled and the NMClient and MRAppMaster will cache the specified number of node manager proxies. There will be at max one proxy per node manager. Ex. configuring it to a value of 5 will make sure that client will at max have 5 proxies cached with 5 different node managers. These connections for these proxies will be timed out if idle for more than the system wide idle timeout period. Note that this could cause issues on large clusters as many connections could linger simultaneously and lead to a large number of connection threads. The token used for authentication will be used only at connection creation time. If a new token is received then the earlier connection should be closed in order to use the new token. This and (yarn.client.nodemanager-client-async.thread-pool-max-size) are related and should be in sync (no need for them to be equal). If the value of this property is zero then the connection cache is disabled and connections will use a zero idle timeout to prevent too many connection threads on large clusters.</td></tr><tr><td>yarn.nodemanager.recovery.enabled</td><td>false</td><td>Enable the node manager to recover after starting</td></tr><tr><td>yarn.nodemanager.recovery.dir</td><td>${hadoop.tmp.dir}/yarn-nm-recovery</td><td>The local filesystem directory in which the node manager will store state when recovery is enabled.</td></tr><tr><td>yarn.nodemanager.recovery.compaction-interval-secs</td><td>3600</td><td>The time in seconds between full compactions of the NM state database. Setting the interval to zero disables the full compaction cycles.</td></tr><tr><td>yarn.nodemanager.docker-container-executor.exec-name</td><td>/usr/bin/docker</td><td>Name or path to the Docker client.</td></tr><tr><td>yarn.nodemanager.aux-services.mapreduce_shuffle.class</td><td>org.apache.hadoop.mapred.ShuffleHandler</td><td></td></tr><tr><td>mapreduce.job.jar</td><td></td><td></td></tr><tr><td>mapreduce.job.hdfs-servers</td><td fs.defaultfs="">$</td><td></td></tr><tr><td>yarn.web-proxy.principal</td><td></td><td>The kerberos principal for the proxy, if the proxy is not running as part of the RM.</td></tr><tr><td>yarn.web-proxy.keytab</td><td></td><td>Keytab for WebAppProxy, if the proxy is not running as part of the RM.</td></tr><tr><td>yarn.web-proxy.address</td><td></td><td>The address for the web proxy as HOST:PORT, if this is not given then the proxy will run as part of the RM</td></tr><tr><td>yarn.application.classpath</td><td></td><td>CLASSPATH for YARN applications. A comma-separated list of CLASSPATH entries. When this value is empty, the following default CLASSPATH for YARN applications would be used. For Linux: $HADOOP_CONF_DIR, $HADOOP_COMMON_HOME/share/hadoop/common/<em>, $HADOOP_COMMON_HOME/share/hadoop/common/lib/</em>, $HADOOP_HDFS_HOME/share/hadoop/hdfs/<em>, $HADOOP_HDFS_HOME/share/hadoop/hdfs/lib/</em>, $HADOOP_YARN_HOME/share/hadoop/yarn/<em>, $HADOOP_YARN_HOME/share/hadoop/yarn/lib/</em> For Windows: %HADOOP_CONF_DIR%, %HADOOP_COMMON_HOME%/share/hadoop/common/<em>, %HADOOP_COMMON_HOME%/share/hadoop/common/lib/</em>, %HADOOP_HDFS_HOME%/share/hadoop/hdfs/<em>, %HADOOP_HDFS_HOME%/share/hadoop/hdfs/lib/</em>, %HADOOP_YARN_HOME%/share/hadoop/yarn/<em>, %HADOOP_YARN_HOME%/share/hadoop/yarn/lib/</em></td></tr><tr><td>yarn.timeline-service.enabled</td><td>false</td><td>Indicate to clients whether timeline service is enabled or not. If enabled, clients will put entities and events to the timeline server.</td></tr><tr><td>yarn.timeline-service.hostname</td><td>0.0.0.0</td><td>The hostname of the timeline service web application.</td></tr><tr><td>yarn.timeline-service.address</td><td>${yarn.timeline-service.hostname}:10200</td><td>This is default address for the timeline server to start the RPC server.</td></tr><tr><td>yarn.timeline-service.webapp.address</td><td>${yarn.timeline-service.hostname}:8188</td><td>The http address of the timeline service web application.</td></tr><tr><td>yarn.timeline-service.webapp.https.address</td><td>${yarn.timeline-service.hostname}:8190</td><td>The https address of the timeline service web application.</td></tr><tr><td>yarn.timeline-service.bind-host</td><td></td><td>The actual address the server will bind to. If this optional address is set, the RPC and webapp servers will bind to this address and the port specified in yarn.timeline-service.address and yarn.timeline-service.webapp.address, respectively. This is most useful for making the service listen to all interfaces by setting to 0.0.0.0.</td></tr><tr><td>yarn.timeline-service.generic-application-history.max-applications</td><td>10000</td><td>Defines the max number of applications could be fetched using REST API or application history protocol and shown in timeline server web ui.</td></tr><tr><td>yarn.timeline-service.store-class</td><td>org.apache.hadoop.yarn.server.timeline.LeveldbTimelineStore</td><td>Store class name for timeline store.</td></tr><tr><td>yarn.timeline-service.ttl-enable</td><td>true</td><td>Enable age off of timeline store data.</td></tr><tr><td>yarn.timeline-service.ttl-ms</td><td>604800000</td><td>Time to live for timeline store data in milliseconds.</td></tr><tr><td>yarn.timeline-service.leveldb-timeline-store.path</td><td>${hadoop.tmp.dir}/yarn/timeline</td><td>Store file name for leveldb timeline store.</td></tr><tr><td>yarn.timeline-service.leveldb-timeline-store.ttl-interval-ms</td><td>300000</td><td>Length of time to wait between deletion cycles of leveldb timeline store in milliseconds.</td></tr><tr><td>yarn.timeline-service.leveldb-timeline-store.read-cache-size</td><td>104857600</td><td>Size of read cache for uncompressed blocks for leveldb timeline store in bytes.</td></tr><tr><td>yarn.timeline-service.leveldb-timeline-store.start-time-read-cache-size</td><td>10000</td><td>Size of cache for recently read entity start times for leveldb timeline store in number of entities.</td></tr><tr><td>yarn.timeline-service.leveldb-timeline-store.start-time-write-cache-size</td><td>10000</td><td>Size of cache for recently written entity start times for leveldb timeline store in number of entities.</td></tr><tr><td>yarn.timeline-service.handler-thread-count</td><td>10</td><td>Handler thread count to serve the client RPC requests.</td></tr><tr><td>yarn.timeline-service.http-authentication.type</td><td>simple</td><td>Defines authentication used for the timeline server HTTP endpoint. Supported values are: simple | kerberos | #AUTHENTICATION_HANDLER_CLASSNAME#</td></tr><tr><td>yarn.timeline-service.http-authentication.simple.anonymous.allowed</td><td>true</td><td>Indicates if anonymous requests are allowed by the timeline server when using 'simple' authentication.</td></tr><tr><td>yarn.timeline-service.principal</td><td></td><td>The Kerberos principal for the timeline server.</td></tr><tr><td>yarn.timeline-service.keytab</td><td>/etc/krb5.keytab</td><td>The Kerberos keytab for the timeline server.</td></tr><tr><td>yarn.timeline-service.client.max-retries</td><td>30</td><td>Default maximum number of retires for timeline servive client.</td></tr><tr><td>yarn.timeline-service.client.retry-interval-ms</td><td>1000</td><td>Default retry time interval for timeline servive client.</td></tr><tr><td>yarn.client.application-client-protocol.poll-interval-ms</td><td>200</td><td>The interval that the yarn client library uses to poll the completion status of the asynchronous API of application client protocol.</td></tr><tr><td>yarn.nodemanager.container-monitor.procfs-tree.smaps-based-rss.enabled</td><td>false</td><td>RSS usage of a process computed via /proc/pid/stat is not very accurate as it includes shared pages of a process. /proc/pid/smaps provides useful information like Private_Dirty, Private_Clean, Shared_Dirty, Shared_Clean which can be used for computing more accurate RSS. When this flag is enabled, RSS is computed as Min(Shared_Dirty, Pss) + Private_Clean + Private_Dirty. It excludes read-only shared mappings in RSS computation.</td></tr><tr><td>hadoop.registry.rm.enabled</td><td>false</td><td>Is the registry enabled: does the RM start it up, create the user and system paths, and purge service records when containers, application attempts and applications complete</td></tr><tr><td>hadoop.registry.zk.root</td><td>/registry</td><td></td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2hhZG9vcC5yZWdpc3RyeS56ay5zZXNzaW9uLnRpbWVvdXQubXM=">hadoop.registry.zk.session.timeout.ms</span></td><td>60000</td><td>Zookeeper session timeout in milliseconds</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2hhZG9vcC5yZWdpc3RyeS56ay5jb25uZWN0aW9uLnRpbWVvdXQubXM=">hadoop.registry.zk.connection.timeout.ms</span></td><td>15000</td><td>Zookeeper session timeout in milliseconds</td></tr><tr><td>hadoop.registry.zk.retry.times</td><td>5</td><td>Zookeeper connection retry count before failing</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2hhZG9vcC5yZWdpc3RyeS56ay5yZXRyeS5pbnRlcnZhbC5tcw==">hadoop.registry.zk.retry.interval.ms</span></td><td>1000</td><td></td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2hhZG9vcC5yZWdpc3RyeS56ay5yZXRyeS5jZWlsaW5nLm1z">hadoop.registry.zk.retry.ceiling.ms</span></td><td>60000</td><td>Zookeeper retry limit in milliseconds, during exponential backoff: {@value} This places a limit even if the retry times and interval limit, combined with the backoff policy, result in a long retry period</td></tr><tr><td>hadoop.registry.zk.quorum</td><td>localhost:2181</td><td>List of hostname:port pairs defining the zookeeper quorum binding for the registry</td></tr><tr><td>hadoop.registry.secure</td><td>false</td><td>Key to set if the registry is secure. Turning it on changes the permissions policy from &quot;open access&quot; to restrictions on kerberos with the option of a user adding one or more auth key pairs down their own tree.</td></tr><tr><td>hadoop.registry.system.acls</td><td>sasl:yarn@, sasl:mapred@, sasl:mapred@hdfs@</td><td>A comma separated list of Zookeeper ACL identifiers with system access to the registry in a secure cluster. These are given full access to all entries. If there is an &quot;@&quot; at the end of a SASL entry it instructs the registry client to append the default kerberos domain.</td></tr><tr><td>hadoop.registry.kerberos.realm</td><td></td><td>The kerberos realm: used to set the realm of system principals which do not declare their realm, and any other accounts that need the value. If empty, the default realm of the running process is used. If neither are known and the realm is needed, then the registry service/client will fail.</td></tr><tr><td>hadoop.registry.jaas.context</td><td>Client</td><td>Key to define the JAAS context. Used in secure mode</td></tr><tr><td>yarn.nodemanager.log-aggregation.roll-monitoring-interval-seconds</td><td>-1</td><td>Defines how often NMs wake up to upload log files. The default value is -1. By default, the logs will be uploaded when the application is finished. By setting this configure, logs can be uploaded periodically when the application is running. The minimum rolling-interval-seconds can be set is 3600.</td></tr></tbody></table><p>core-site.xml</p><table><thead><tr><th>name</th><th>value</th><th>description</th></tr></thead><tbody><tr><td>hadoop.common.configuration.version</td><td>0.23.0</td><td>version of this configuration file</td></tr><tr><td>hadoop.tmp.dir</td><td user.name="">/tmp/hadoop-$</td><td>A base for other temporary directories.</td></tr><tr><td>io.native.lib.available</td><td>true</td><td>Should native hadoop libraries, if present, be used.</td></tr><tr><td>hadoop.http.filter.initializers</td><td>org.apache.hadoop.http.lib.StaticUserWebFilter</td><td>A comma separated list of class names. Each class in the list must extend org.apache.hadoop.http.FilterInitializer. The corresponding Filter will be initialized. Then, the Filter will be applied to all user facing jsp and servlet web pages. The ordering of the list defines the ordering of the filters.</td></tr><tr><td>hadoop.security.authorization</td><td>false</td><td>Is service-level authorization enabled?</td></tr><tr><td>hadoop.security.instrumentation.requires.admin</td><td>false</td><td>Indicates if administrator ACLs are required to access instrumentation servlets (JMX, METRICS, CONF, STACKS).</td></tr><tr><td>hadoop.security.authentication</td><td>simple</td><td>Possible values are simple (no authentication), and kerberos</td></tr><tr><td>hadoop.security.group.mapping</td><td>org.apache.hadoop.security.JniBasedUnixGroupsMappingWithFallback</td><td>Class for user to group mapping (get groups for a given user) for ACL. The default implementation, org.apache.hadoop.security.JniBasedUnixGroupsMappingWithFallback, will determine if the Java Native Interface (JNI) is available. If JNI is available the implementation will use the API within hadoop to resolve a list of groups for a user. If JNI is not available then the shell implementation, ShellBasedUnixGroupsMapping, is used. This implementation shells out to the Linux/Unix environment with the bash -c groups command to resolve a list of groups for a user.</td></tr><tr><td>hadoop.security.groups.cache.secs</td><td>300</td><td>This is the config controlling the validity of the entries in the cache containing the user-&gt;group mapping. When this duration has expired, then the implementation of the group mapping provider is invoked to get the groups of the user and then cached back.</td></tr><tr><td>hadoop.security.groups.negative-cache.secs</td><td>30</td><td>Expiration time for entries in the the negative user-to-group mapping caching, in seconds. This is useful when invalid users are retrying frequently. It is suggested to set a small value for this expiration, since a transient error in group lookup could temporarily lock out a legitimate user. Set this to zero or negative value to disable negative user-to-group caching.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2hhZG9vcC5zZWN1cml0eS5ncm91cHMuY2FjaGUud2Fybi5hZnRlci5tcw==">hadoop.security.groups.cache.warn.after.ms</span></td><td>5000</td><td>If looking up a single user to group takes longer than this amount of milliseconds, we will log a warning message.</td></tr><tr><td>hadoop.security.group.mapping.ldap.url</td><td></td><td>The URL of the LDAP server to use for resolving user groups when using the LdapGroupsMapping user to group mapping.</td></tr><tr><td>hadoop.security.group.mapping.ldap.ssl</td><td>false</td><td>Whether or not to use SSL when connecting to the LDAP server.</td></tr><tr><td>hadoop.security.group.mapping.ldap.ssl.keystore</td><td></td><td>File path to the SSL keystore that contains the SSL certificate required by the LDAP server.</td></tr><tr><td>hadoop.security.group.mapping.ldap.ssl.keystore.password.file</td><td></td><td>The path to a file containing the password of the LDAP SSL keystore. IMPORTANT: This file should be readable only by the Unix user running the daemons.</td></tr><tr><td>hadoop.security.group.mapping.ldap.bind.user</td><td></td><td>The distinguished name of the user to bind as when connecting to the LDAP server. This may be left blank if the LDAP server supports anonymous binds.</td></tr><tr><td>hadoop.security.group.mapping.ldap.bind.password.file</td><td></td><td>The path to a file containing the password of the bind user. IMPORTANT: This file should be readable only by the Unix user running the daemons.</td></tr><tr><td>hadoop.security.group.mapping.ldap.base</td><td></td><td>The search base for the LDAP connection. This is a distinguished name, and will typically be the root of the LDAP directory.</td></tr><tr><td>hadoop.security.group.mapping.ldap.search.filter.user</td><td>(&amp;(objectClass=user)(sAMAccountName={0}))</td><td>An additional filter to use when searching for LDAP users. The default will usually be appropriate for Active Directory installations. If connecting to an LDAP server with a non-AD schema, this should be replaced with (&amp;(objectClass=inetOrgPerson)(uid={0}). {0} is a special string used to denote where the username fits into the filter.</td></tr><tr><td>hadoop.security.group.mapping.ldap.search.filter.group</td><td>(objectClass=group)</td><td>An additional filter to use when searching for LDAP groups. This should be changed when resolving groups against a non-Active Directory installation. posixGroups are currently not a supported group class.</td></tr><tr><td>hadoop.security.group.mapping.ldap.search.attr.member</td><td>member</td><td>The attribute of the group object that identifies the users that are members of the group. The default will usually be appropriate for any LDAP installation.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2hhZG9vcC5zZWN1cml0eS5ncm91cC5tYXBwaW5nLmxkYXAuc2VhcmNoLmF0dHIuZ3JvdXAubmFtZQ==">hadoop.security.group.mapping.ldap.search.attr.group.name</span></td><td>cn</td><td>The attribute of the group object that identifies the group name. The default will usually be appropriate for all LDAP systems.</td></tr><tr><td>hadoop.security.group.mapping.ldap.directory.search.timeout</td><td>10000</td><td>The attribute applied to the LDAP SearchControl properties to set a maximum time limit when searching and awaiting a result. Set to 0 if infinite wait period is desired. Default is 10 seconds. Units in milliseconds.</td></tr><tr><td>hadoop.security.service.user.name.key</td><td></td><td>For those cases where the same RPC protocol is implemented by multiple servers, this configuration is required for specifying the principal name to use for the service when the client wishes to make an RPC call.</td></tr><tr><td>hadoop.security.uid.cache.secs</td><td>14400</td><td>This is the config controlling the validity of the entries in the cache containing the userId to userName and groupId to groupName used by NativeIO getFstat().</td></tr><tr><td>hadoop.rpc.protection</td><td>authentication</td><td>A comma-separated list of protection values for secured sasl connections. Possible values are authentication, integrity and privacy. authentication means authentication only and no integrity or privacy; integrity implies authentication and integrity are enabled; and privacy implies all of authentication, integrity and privacy are enabled. hadoop.security.saslproperties.resolver.class can be used to override the hadoop.rpc.protection for a connection at the server side.</td></tr><tr><td>hadoop.security.saslproperties.resolver.class</td><td></td><td>SaslPropertiesResolver used to resolve the QOP used for a connection. If not specified, the full set of values specified in hadoop.rpc.protection is used while determining the QOP used for the connection. If a class is specified, then the QOP values returned by the class will be used while determining the QOP used for the connection.</td></tr><tr><td>hadoop.work.around.non.threadsafe.getpwuid</td><td>false</td><td>Some operating systems or authentication modules are known to have broken implementations of getpwuid_r and getpwgid_r, such that these calls are not thread-safe. Symptoms of this problem include JVM crashes with a stack trace inside these functions. If your system exhibits this issue, enable this configuration parameter to include a lock around the calls as a workaround. An incomplete list of some systems known to have this issue is available at <span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFwYWNoZS5vcmcvaGFkb29wL0tub3duQnJva2VuUHd1aWRJbXBsZW1lbnRhdGlvbnM=">https://wiki.apache.org/hadoop/KnownBrokenPwuidImplementations</span></td></tr><tr><td>hadoop.kerberos.kinit.command</td><td>kinit</td><td>Used to periodically renew Kerberos credentials when provided to Hadoop. The default setting assumes that kinit is in the PATH of users running the Hadoop client. Change this to the absolute path to kinit if this is not the case.</td></tr><tr><td>hadoop.security.auth_to_local</td><td></td><td>Maps kerberos principals to local user names</td></tr><tr><td>io.file.buffer.size</td><td>4096</td><td>The size of buffer for use in sequence files. The size of this buffer should probably be a multiple of hardware page size (4096 on Intel x86), and it determines how much data is buffered during read and write operations.</td></tr><tr><td>io.bytes.per.checksum</td><td>512</td><td>The number of bytes per checksum. Must not be larger than io.file.buffer.size.</td></tr><tr><td>io.skip.checksum.errors</td><td>false</td><td>If true, when a checksum error is encountered while reading a sequence file, entries are skipped, instead of throwing an exception.</td></tr><tr><td>io.compression.codecs</td><td></td><td>A comma-separated list of the compression codec classes that can be used for compression/decompression. In addition to any classes specified with this property (which take precedence), codec classes on the classpath are discovered using a Java ServiceLoader.</td></tr><tr><td>io.compression.codec.bzip2.library</td><td>system-native</td><td>The native-code library to be used for compression and decompression by the bzip2 codec. This library could be specified either by by name or the full pathname. In the former case, the library is located by the dynamic linker, usually searching the directories specified in the environment variable LD_LIBRARY_PATH. The value of &quot;system-native&quot; indicates that the default system library should be used. To indicate that the algorithm should operate entirely in Java, specify &quot;java-builtin&quot;.</td></tr><tr><td>io.serializations</td><td>org.apache.hadoop.io.serializer.WritableSerialization,org.apache.hadoop.io.serializer.avro.AvroSpecificSerialization,org.apache.hadoop.io.serializer.avro.AvroReflectSerialization</td><td>A list of serialization classes that can be used for obtaining serializers and deserializers.</td></tr><tr><td>io.seqfile.local.dir</td><td>${hadoop.tmp.dir}/io/local</td><td>The local directory where sequence file stores intermediate data files during merge. May be a comma-separated list of directories on different devices in order to spread disk i/o. Directories that do not exist are ignored.</td></tr><tr><td>io.map.index.skip</td><td>0</td><td>Number of index entries to skip between each entry. Zero by default. Setting this to values larger than zero can facilitate opening large MapFiles using less memory.</td></tr><tr><td>io.map.index.interval</td><td>128</td><td>MapFile consist of two files - data file (tuples) and index file (keys). For every io.map.index.interval records written in the data file, an entry (record-key, data-file-position) is written in the index file. This is to allow for doing binary search later within the index file to look up records by their keys and get their closest positions in the data file.</td></tr><tr><td>fs.defaultFS</td><td>file:///</td><td>The name of the default file system. A URI whose scheme and authority determine the FileSystem implementation. The uri's scheme determines the config property (fs.SCHEME.impl) naming the FileSystem implementation class. The uri's authority is used to determine the host, port, etc. for a filesystem.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2ZzLmRlZmF1bHQubmFtZQ==">fs.default.name</span></td><td>file:///</td><td>Deprecated. Use (fs.defaultFS) property instead</td></tr><tr><td>fs.trash.interval</td><td>0</td><td>Number of minutes after which the checkpoint gets deleted. If zero, the trash feature is disabled. This option may be configured both on the server and the client. If trash is disabled server side then the client side configuration is checked. If trash is enabled on the server side then the value configured on the server is used and the client configuration value is ignored.</td></tr><tr><td>fs.trash.checkpoint.interval</td><td>0</td><td>Number of minutes between trash checkpoints. Should be smaller or equal to fs.trash.interval. If zero, the value is set to the value of fs.trash.interval. Every time the checkpointer runs it creates a new checkpoint out of current and removes checkpoints created more than fs.trash.interval minutes ago.</td></tr><tr><td>fs.AbstractFileSystem.file.impl</td><td>org.apache.hadoop.fs.local.LocalFs</td><td>The AbstractFileSystem for file: uris.</td></tr><tr><td>fs.AbstractFileSystem.har.impl</td><td>org.apache.hadoop.fs.HarFs</td><td>The AbstractFileSystem for har: uris.</td></tr><tr><td>fs.AbstractFileSystem.hdfs.impl</td><td>org.apache.hadoop.fs.Hdfs</td><td>The FileSystem for hdfs: uris.</td></tr><tr><td>fs.AbstractFileSystem.viewfs.impl</td><td>org.apache.hadoop.fs.viewfs.ViewFs</td><td>The AbstractFileSystem for view file system for viewfs: uris (ie client side mount table:).</td></tr><tr><td>fs.ftp.host</td><td>0.0.0.0</td><td>FTP filesystem connects to this server</td></tr><tr><td>fs.ftp.host.port</td><td>21</td><td>FTP filesystem connects to fs.ftp.host on this port</td></tr><tr><td>fs.df.interval</td><td>60000</td><td>Disk usage statistics refresh interval in msec.</td></tr><tr><td>fs.du.interval</td><td>600000</td><td>File space usage statistics refresh interval in msec.</td></tr><tr><td>fs.s3.block.size</td><td>67108864</td><td>Block size to use when writing files to S3.</td></tr><tr><td>fs.s3.buffer.dir</td><td>${hadoop.tmp.dir}/s3</td><td>Determines where on the local filesystem the S3 filesystem should store files before sending them to S3 (or after retrieving them from S3).</td></tr><tr><td>fs.s3.maxRetries</td><td>4</td><td>The maximum number of retries for reading or writing files to S3, before we signal failure to the application.</td></tr><tr><td>fs.s3.sleepTimeSeconds</td><td>10</td><td>The number of seconds to sleep between each S3 retry.</td></tr><tr><td>fs.swift.impl</td><td>org.apache.hadoop.fs.swift.snative.SwiftNativeFileSystem</td><td>The implementation class of the OpenStack Swift Filesystem</td></tr><tr><td>fs.automatic.close</td><td>true</td><td>By default, FileSystem instances are automatically closed at program exit using a JVM shutdown hook. Setting this property to false disables this behavior. This is an advanced option that should only be used by server applications requiring a more carefully orchestrated shutdown sequence.</td></tr><tr><td>fs.s3n.block.size</td><td>67108864</td><td>Block size to use when reading files using the native S3 filesystem (s3n: URIs).</td></tr><tr><td>fs.s3n.multipart.uploads.enabled</td><td>false</td><td>Setting this property to true enables multiple uploads to native S3 filesystem. When uploading a file, it is split into blocks if the size is larger than fs.s3n.multipart.uploads.block.size.</td></tr><tr><td>fs.s3n.multipart.uploads.block.size</td><td>67108864</td><td>The block size for multipart uploads to native S3 filesystem. Default size is 64MB.</td></tr><tr><td>fs.s3n.multipart.copy.block.size</td><td>5368709120</td><td>The block size for multipart copy in native S3 filesystem. Default size is 5GB.</td></tr><tr><td>fs.s3n.server-side-encryption-algorithm</td><td></td><td>Specify a server-side encryption algorithm for S3. The default is NULL, and the only other currently allowable value is AES256.</td></tr><tr><td>fs.s3a.access.key</td><td></td><td>AWS access key ID. Omit for Role-based authentication.</td></tr><tr><td>fs.s3a.secret.key</td><td></td><td>AWS secret key. Omit for Role-based authentication.</td></tr><tr><td>fs.s3a.connection.maximum</td><td>15</td><td>Controls the maximum number of simultaneous connections to S3.</td></tr><tr><td>fs.s3a.connection.ssl.enabled</td><td>true</td><td>Enables or disables SSL connections to S3.</td></tr><tr><td>fs.s3a.attempts.maximum</td><td>10</td><td>How many times we should retry commands on transient errors.</td></tr><tr><td>fs.s3a.connection.timeout</td><td>5000</td><td>Socket connection timeout in seconds.</td></tr><tr><td>fs.s3a.paging.maximum</td><td>5000</td><td>How many keys to request from S3 when doing directory listings at a time.</td></tr><tr><td>fs.s3a.multipart.size</td><td>104857600</td><td>How big (in bytes) to split upload or copy operations up into.</td></tr><tr><td>fs.s3a.multipart.threshold</td><td>2147483647</td><td>Threshold before uploads or copies use parallel multipart operations.</td></tr><tr><td>fs.s3a.acl.default</td><td></td><td>Set a canned ACL for newly created and copied objects. Value may be private, public-read, public-read-write, authenticated-read, log-delivery-write, bucket-owner-read, or bucket-owner-full-control.</td></tr><tr><td>fs.s3a.multipart.purge</td><td>false</td><td>True if you want to purge existing multipart uploads that may not have been completed/aborted correctly</td></tr><tr><td>fs.s3a.multipart.purge.age</td><td>86400</td><td>Minimum age in seconds of multipart uploads to purge</td></tr><tr><td>fs.s3a.buffer.dir</td><td>${hadoop.tmp.dir}/s3a</td><td>Comma separated list of directories that will be used to buffer file uploads to.</td></tr><tr><td>fs.s3a.impl</td><td>org.apache.hadoop.fs.s3a.S3AFileSystem</td><td>The implementation class of the S3A Filesystem</td></tr><tr><td>io.seqfile.compress.blocksize</td><td>1000000</td><td>The minimum block size for compression in block compressed SequenceFiles.</td></tr><tr><td>io.seqfile.lazydecompress</td><td>true</td><td>Should values of block-compressed SequenceFiles be decompressed only when necessary.</td></tr><tr><td>io.seqfile.sorter.recordlimit</td><td>1000000</td><td>The limit on number of records to be kept in memory in a spill in SequenceFiles.Sorter</td></tr><tr><td>io.mapfile.bloom.size</td><td>1048576</td><td>The size of BloomFilter-s used in BloomMapFile. Each time this many keys is appended the next BloomFilter will be created (inside a DynamicBloomFilter). Larger values minimize the number of filters, which slightly increases the performance, but may waste too much space if the total number of keys is usually much smaller than this number.</td></tr><tr><td>io.mapfile.bloom.error.rate</td><td>0.005</td><td>The rate of false positives in BloomFilter-s used in BloomMapFile. As this value decreases, the size of BloomFilter-s increases exponentially. This value is the probability of encountering false positives (default is 0.5%).</td></tr><tr><td>hadoop.util.hash.type</td><td>murmur</td><td>The default implementation of Hash. Currently this can take one of the two values: 'murmur' to select MurmurHash and 'jenkins' to select JenkinsHash.</td></tr><tr><td>ipc.client.idlethreshold</td><td>4000</td><td>Defines the threshold number of connections after which connections will be inspected for idleness.</td></tr><tr><td>ipc.client.kill.max</td><td>10</td><td>Defines the maximum number of clients to disconnect in one go.</td></tr><tr><td>ipc.client.connection.maxidletime</td><td>10000</td><td>The maximum time in msec after which a client will bring down the connection to the server.</td></tr><tr><td>ipc.client.connect.max.retries</td><td>10</td><td>Indicates the number of retries a client will make to establish a server connection.</td></tr><tr><td>ipc.client.connect.retry.interval</td><td>1000</td><td>Indicates the number of milliseconds a client will wait for before retrying to establish a server connection.</td></tr><tr><td>ipc.client.connect.timeout</td><td>20000</td><td>Indicates the number of milliseconds a client will wait for the socket to establish a server connection.</td></tr><tr><td>ipc.client.connect.max.retries.on.timeouts</td><td>45</td><td>Indicates the number of retries a client will make on socket timeout to establish a server connection.</td></tr><tr><td>ipc.client.ping</td><td>true</td><td>Send a ping to the server when timeout on reading the response, if set to true. If no failure is detected, the client retries until at least a byte is read.</td></tr><tr><td>ipc.ping.interval</td><td>60000</td><td>Timeout on waiting response from server, in milliseconds. The client will send ping when the interval is passed without receiving bytes, if ipc.client.ping is set to true.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2lwYy5jbGllbnQucnBjLXRpbWVvdXQubXM=">ipc.client.rpc-timeout.ms</span></td><td>0</td><td>Timeout on waiting response from server, in milliseconds. Currently this timeout works only when ipc.client.ping is set to true because it uses the same facilities with IPC ping. The timeout overrides the ipc.ping.interval and client will throw exception instead of sending ping when the interval is passed.</td></tr><tr><td>ipc.server.listen.queue.size</td><td>128</td><td>Indicates the length of the listen queue for servers accepting client connections.</td></tr><tr><td>hadoop.security.impersonation.provider.class</td><td></td><td>A class which implements ImpersonationProvider interface, used to authorize whether one user can impersonate a specific user. If not specified, the DefaultImpersonationProvider will be used. If a class is specified, then that class will be used to determine the impersonation capability.</td></tr><tr><td>hadoop.rpc.socket.factory.class.default</td><td>org.apache.hadoop.net.StandardSocketFactory</td><td>Default SocketFactory to use. This parameter is expected to be formatted as &quot;package.FactoryClassName&quot;.</td></tr><tr><td>hadoop.rpc.socket.factory.class.ClientProtocol</td><td></td><td>SocketFactory to use to connect to a DFS. If null or empty, use hadoop.rpc.socket.class.default. This socket factory is also used by DFSClient to create sockets to DataNodes.</td></tr><tr><td>hadoop.socks.server</td><td></td><td>Address (host:port) of the SOCKS server to be used by the SocksSocketFactory.</td></tr><tr><td>net.topology.node.switch.mapping.impl</td><td>org.apache.hadoop.net.ScriptBasedMapping</td><td>The default implementation of the DNSToSwitchMapping. It invokes a script specified in <span class="exturl" data-url="aHR0cDovL25ldC50b3BvbG9neS5zY3JpcHQuZmlsZS5uYW1l">net.topology.script.file.name</span> to resolve node names. If the value for <span class="exturl" data-url="aHR0cDovL25ldC50b3BvbG9neS5zY3JpcHQuZmlsZS5uYW1l">net.topology.script.file.name</span> is not set, the default value of DEFAULT_RACK is returned for all node names.</td></tr><tr><td>net.topology.impl</td><td>org.apache.hadoop.net.NetworkTopology</td><td>The default implementation of NetworkTopology which is classic three layer one.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL25ldC50b3BvbG9neS5zY3JpcHQuZmlsZS5uYW1l">net.topology.script.file.name</span></td><td></td><td>The script name that should be invoked to resolve DNS names to NetworkTopology names. Example: the script would take host.foo.bar as an argument, and return /rack1 as the output.</td></tr><tr><td>net.topology.script.number.args</td><td>100</td><td>The max number of args that the script configured with <span class="exturl" data-url="aHR0cDovL25ldC50b3BvbG9neS5zY3JpcHQuZmlsZS5uYW1l">net.topology.script.file.name</span> should be run with. Each arg is an IP address.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL25ldC50b3BvbG9neS50YWJsZS5maWxlLm5hbWU=">net.topology.table.file.name</span></td><td></td><td>The file name for a topology file, which is used when the net.topology.node.switch.mapping.impl property is set to org.apache.hadoop.net.TableMapping. The file format is a two column text file, with columns separated by whitespace. The first column is a DNS or IP address and the second column specifies the rack where the address maps. If no entry corresponding to a host in the cluster is found, then /default-rack is assumed.</td></tr><tr><td>file.stream-buffer-size</td><td>4096</td><td>The size of buffer to stream files. The size of this buffer should probably be a multiple of hardware page size (4096 on Intel x86), and it determines how much data is buffered during read and write operations.</td></tr><tr><td>file.bytes-per-checksum</td><td>512</td><td>The number of bytes per checksum. Must not be larger than file.stream-buffer-size</td></tr><tr><td>file.client-write-packet-size</td><td>65536</td><td>Packet size for clients to write</td></tr><tr><td>file.blocksize</td><td>67108864</td><td>Block size</td></tr><tr><td>file.replication</td><td>1</td><td>Replication factor</td></tr><tr><td>s3.stream-buffer-size</td><td>4096</td><td>The size of buffer to stream files. The size of this buffer should probably be a multiple of hardware page size (4096 on Intel x86), and it determines how much data is buffered during read and write operations.</td></tr><tr><td>s3.bytes-per-checksum</td><td>512</td><td>The number of bytes per checksum. Must not be larger than s3.stream-buffer-size</td></tr><tr><td>s3.client-write-packet-size</td><td>65536</td><td>Packet size for clients to write</td></tr><tr><td>s3.blocksize</td><td>67108864</td><td>Block size</td></tr><tr><td>s3.replication</td><td>3</td><td>Replication factor</td></tr><tr><td>s3native.stream-buffer-size</td><td>4096</td><td>The size of buffer to stream files. The size of this buffer should probably be a multiple of hardware page size (4096 on Intel x86), and it determines how much data is buffered during read and write operations.</td></tr><tr><td>s3native.bytes-per-checksum</td><td>512</td><td>The number of bytes per checksum. Must not be larger than s3native.stream-buffer-size</td></tr><tr><td>s3native.client-write-packet-size</td><td>65536</td><td>Packet size for clients to write</td></tr><tr><td>s3native.blocksize</td><td>67108864</td><td>Block size</td></tr><tr><td>s3native.replication</td><td>3</td><td>Replication factor</td></tr><tr><td>ftp.stream-buffer-size</td><td>4096</td><td>The size of buffer to stream files. The size of this buffer should probably be a multiple of hardware page size (4096 on Intel x86), and it determines how much data is buffered during read and write operations.</td></tr><tr><td>ftp.bytes-per-checksum</td><td>512</td><td>The number of bytes per checksum. Must not be larger than ftp.stream-buffer-size</td></tr><tr><td>ftp.client-write-packet-size</td><td>65536</td><td>Packet size for clients to write</td></tr><tr><td>ftp.blocksize</td><td>67108864</td><td>Block size</td></tr><tr><td>ftp.replication</td><td>3</td><td>Replication factor</td></tr><tr><td>tfile.io.chunk.size</td><td>1048576</td><td>Value chunk size in bytes. Default to 1MB. Values of the length less than the chunk size is guaranteed to have known value length in read time (See also TFile.Reader.Scanner.Entry.isValueLengthKnown()).</td></tr><tr><td>tfile.fs.output.buffer.size</td><td>262144</td><td>Buffer size used for FSDataOutputStream in bytes.</td></tr><tr><td>tfile.fs.input.buffer.size</td><td>262144</td><td>Buffer size used for FSDataInputStream in bytes.</td></tr><tr><td>hadoop.http.authentication.type</td><td>simple</td><td>Defines authentication used for Oozie HTTP endpoint. Supported values are: simple | kerberos | #AUTHENTICATION_HANDLER_CLASSNAME#</td></tr><tr><td>hadoop.http.authentication.token.validity</td><td>36000</td><td>Indicates how long (in seconds) an authentication token is valid before it has to be renewed.</td></tr><tr><td>hadoop.http.authentication.signature.secret.file</td><td>${user.home}/hadoop-http-auth-signature-secret</td><td>The signature secret for signing the authentication tokens. The same secret should be used for JT/NN/DN/TT configurations.</td></tr><tr><td>hadoop.http.authentication.cookie.domain</td><td></td><td>The domain to use for the HTTP cookie that stores the authentication token. In order to authentiation to work correctly across all Hadoop nodes web-consoles the domain must be correctly set. IMPORTANT: when using IP addresses, browsers ignore cookies with domain settings. For this setting to work properly all nodes in the cluster must be configured to generate URLs with hostname.domain names on it.</td></tr><tr><td>hadoop.http.authentication.simple.anonymous.allowed</td><td>true</td><td>Indicates if anonymous requests are allowed when using 'simple' authentication.</td></tr><tr><td>hadoop.http.authentication.kerberos.principal</td><td>HTTP/_HOST@LOCALHOST</td><td>Indicates the Kerberos principal to be used for HTTP endpoint. The principal MUST start with 'HTTP/' as per Kerberos HTTP SPNEGO specification.</td></tr><tr><td>hadoop.http.authentication.kerberos.keytab</td><td>${user.home}/hadoop.keytab</td><td>Location of the keytab file with the credentials for the principal. Referring to the same keytab file Oozie uses for its Kerberos credentials for Hadoop.</td></tr><tr><td>dfs.ha.fencing.methods</td><td></td><td>List of fencing methods to use for service fencing. May contain builtin methods (eg shell and sshfence) or user-defined method.</td></tr><tr><td>dfs.ha.fencing.ssh.connect-timeout</td><td>30000</td><td>SSH connection timeout, in milliseconds, to use with the builtin sshfence fencer.</td></tr><tr><td>dfs.ha.fencing.ssh.private-key-files</td><td></td><td>The SSH private key files to use with the builtin sshfence fencer.</td></tr><tr><td>hadoop.http.staticuser.user</td><td>dr.who</td><td>The user name to filter as, on static web filters while rendering content. An example use is the HDFS web UI (user to be used for browsing files).</td></tr><tr><td>ha.zookeeper.quorum</td><td></td><td>A list of ZooKeeper server addresses, separated by commas, that are to be used by the ZKFailoverController in automatic failover.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2hhLnpvb2tlZXBlci5zZXNzaW9uLXRpbWVvdXQubXM=">ha.zookeeper.session-timeout.ms</span></td><td>5000</td><td>The session timeout to use when the ZKFC connects to ZooKeeper. Setting this value to a lower value implies that server crashes will be detected more quickly, but risks triggering failover too aggressively in the case of a transient error or network blip.</td></tr><tr><td>ha.zookeeper.parent-znode</td><td>/hadoop-ha</td><td>The ZooKeeper znode under which the ZK failover controller stores its information. Note that the nameservice ID is automatically appended to this znode, so it is not normally necessary to configure this, even in a federated environment.</td></tr><tr><td>ha.zookeeper.acl</td><td>world:anyone:rwcda</td><td>A comma-separated list of ZooKeeper ACLs to apply to the znodes used by automatic failover. These ACLs are specified in the same format as used by the ZooKeeper CLI. If the ACL itself contains secrets, you may instead specify a path to a file, prefixed with the '@' symbol, and the value of this configuration will be loaded from within.</td></tr><tr><td>ha.zookeeper.auth</td><td></td><td>A comma-separated list of ZooKeeper authentications to add when connecting to ZooKeeper. These are specified in the same format as used by the &quot;addauth&quot; command in the ZK CLI. It is important that the authentications specified here are sufficient to access znodes with the ACL specified in ha.zookeeper.acl. If the auths contain secrets, you may instead specify a path to a file, prefixed with the '@' symbol, and the value of this configuration will be loaded from within.</td></tr><tr><td>hadoop.ssl.keystores.factory.class</td><td>org.apache.hadoop.security.ssl.FileBasedKeyStoresFactory</td><td>The keystores factory to use for retrieving certificates.</td></tr><tr><td>hadoop.ssl.require.client.cert</td><td>false</td><td>Whether client certificates are required</td></tr><tr><td>hadoop.ssl.hostname.verifier</td><td>DEFAULT</td><td>The hostname verifier to provide for HttpsURLConnections. Valid values are: DEFAULT, STRICT, STRICT_I6, DEFAULT_AND_LOCALHOST and ALLOW_ALL</td></tr><tr><td>hadoop.ssl.server.conf</td><td>ssl-server.xml</td><td>Resource file from which ssl server keystore information will be extracted. This file is looked up in the classpath, typically it should be in Hadoop conf/ directory.</td></tr><tr><td>hadoop.ssl.client.conf</td><td>ssl-client.xml</td><td>Resource file from which ssl client keystore information will be extracted This file is looked up in the classpath, typically it should be in Hadoop conf/ directory.</td></tr><tr><td>hadoop.ssl.enabled</td><td>false</td><td>Deprecated. Use dfs.http.policy and yarn.http.policy instead.</td></tr><tr><td>hadoop.ssl.enabled.protocols</td><td>TLSv1</td><td>Protocols supported by the ssl.</td></tr><tr><td>hadoop.jetty.logs.serve.aliases</td><td>true</td><td>Enable/Disable aliases serving from jetty</td></tr><tr><td>fs.permissions.umask-mode</td><td>022</td><td>The umask used when creating files and directories. Can be in octal or in symbolic. Examples are: &quot;022&quot; (octal for u=rwx,g=r-x,o=r-x in symbolic), or &quot;u=rwx,g=rwx,o=&quot; (symbolic for 007 in octal).</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2hhLmhlYWx0aC1tb25pdG9yLmNvbm5lY3QtcmV0cnktaW50ZXJ2YWwubXM=">ha.health-monitor.connect-retry-interval.ms</span></td><td>1000</td><td>How often to retry connecting to the service.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2hhLmhlYWx0aC1tb25pdG9yLmNoZWNrLWludGVydmFsLm1z">ha.health-monitor.check-interval.ms</span></td><td>1000</td><td>How often to check the service.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2hhLmhlYWx0aC1tb25pdG9yLnNsZWVwLWFmdGVyLWRpc2Nvbm5lY3QubXM=">ha.health-monitor.sleep-after-disconnect.ms</span></td><td>1000</td><td>How long to sleep after an unexpected RPC error.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2hhLmhlYWx0aC1tb25pdG9yLnJwYy10aW1lb3V0Lm1z">ha.health-monitor.rpc-timeout.ms</span></td><td>45000</td><td>Timeout for the actual monitorHealth() calls.</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2hhLmZhaWxvdmVyLWNvbnRyb2xsZXIubmV3LWFjdGl2ZS5ycGMtdGltZW91dC5tcw==">ha.failover-controller.new-active.rpc-timeout.ms</span></td><td>60000</td><td>Timeout that the FC waits for the new active to become active</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2hhLmZhaWxvdmVyLWNvbnRyb2xsZXIuZ3JhY2VmdWwtZmVuY2UucnBjLXRpbWVvdXQubXM=">ha.failover-controller.graceful-fence.rpc-timeout.ms</span></td><td>5000</td><td>Timeout that the FC waits for the old active to go to standby</td></tr><tr><td>ha.failover-controller.graceful-fence.connection.retries</td><td>1</td><td>FC connection retries for graceful fencing</td></tr><tr><td><span class="exturl" data-url="aHR0cDovL2hhLmZhaWxvdmVyLWNvbnRyb2xsZXIuY2xpLWNoZWNrLnJwYy10aW1lb3V0Lm1z">ha.failover-controller.cli-check.rpc-timeout.ms</span></td><td>20000</td><td>Timeout that the CLI (manual) FC waits for monitorHealth, getServiceState</td></tr><tr><td>ipc.client.fallback-to-simple-auth-allowed</td><td>false</td><td>When a client is configured to attempt a secure connection, but attempts to connect to an insecure server, that server may instruct the client to switch to SASL SIMPLE (unsecure) authentication. This setting controls whether or not the client will accept this instruction from the server. When false (the default), the client will not allow the fallback to SIMPLE authentication, and will abort the connection.</td></tr><tr><td>fs.client.resolve.remote.symlinks</td><td>true</td><td>Whether to resolve symlinks when accessing a remote Hadoop filesystem. Setting this to false causes an exception to be thrown upon encountering a symlink. This setting does not apply to local filesystems, which automatically resolve local symlinks.</td></tr><tr><td>nfs.exports.allowed.hosts</td><td>* rw</td><td>By default, the export can be mounted by any client. The value string contains machine name and access privilege, separated by whitespace characters. The machine name format can be a single host, a Java regular expression, or an IPv4 address. The access privilege uses rw or ro to specify read/write or read-only access of the machines to exports. If the access privilege is not provided, the default is read-only. Entries are separated by &quot;;&quot;. For example: &quot;192.168.0.0/22 rw ; host.*.example.com ; <span class="exturl" data-url="aHR0cDovL2hvc3QxLnRlc3Qub3Jn">host1.test.org</span> ro;&quot;. Only the NFS gateway needs to restart after this property is updated.</td></tr><tr><td>hadoop.user.group.static.mapping.overrides</td><td>dr.who=;</td><td>Static mapping of user to groups. This will override the groups if available in the system for the specified user. In otherwords, groups look-up will not happen for these users, instead groups mapped in this configuration will be used. Mapping should be in this format. user1=group1,group2;user2=;user3=group2; Default, &quot;dr.who=;&quot; will consider &quot;dr.who&quot; as user without groups.</td></tr><tr><td>rpc.metrics.quantile.enable</td><td>false</td><td>Setting this property to true and rpc.metrics.percentiles.intervals to a comma-separated list of the granularity in seconds, the 50/75/90/95/99th percentile latency for rpc queue/processing time in milliseconds are added to rpc metrics.</td></tr><tr><td>rpc.metrics.percentiles.intervals</td><td></td><td>A comma-separated list of the granularity in seconds for the metrics which describe the 50/75/90/95/99th percentile latency for rpc queue/processing time. The metrics are outputted if rpc.metrics.quantile.enable is set to true.</td></tr><tr><td>hadoop.security.crypto.codec.classes.EXAMPLECIPHERSUITE</td><td></td><td>The prefix for a given crypto codec, contains a comma-separated list of implementation classes for a given crypto codec (eg EXAMPLECIPHERSUITE). The first implementation will be used if available, others are fallbacks.</td></tr><tr><td>hadoop.security.crypto.codec.classes.aes.ctr.nopadding</td><td>org.apache.hadoop.crypto.OpensslAesCtrCryptoCodec,org.apache.hadoop.crypto.JceAesCtrCryptoCodec</td><td>Comma-separated list of crypto codec implementations for AES/CTR/NoPadding. The first implementation will be used if available, others are fallbacks.</td></tr><tr><td>hadoop.security.crypto.cipher.suite</td><td>AES/CTR/NoPadding</td><td>Cipher suite for crypto codec.</td></tr><tr><td>hadoop.security.crypto.jce.provider</td><td></td><td>The JCE provider name used in CryptoCodec.</td></tr><tr><td>hadoop.security.crypto.buffer.size</td><td>8192</td><td>The buffer size used by CryptoInputStream and CryptoOutputStream.</td></tr><tr><td>hadoop.security.java.secure.random.algorithm</td><td>SHA1PRNG</td><td>The java secure random algorithm.</td></tr><tr><td>hadoop.security.secure.random.impl</td><td></td><td>Implementation of secure random.</td></tr><tr><td>hadoop.security.random.device.file.path</td><td>/dev/urandom</td><td>OS security random device file path.</td></tr><tr><td>fs.har.impl.disable.cache</td><td>true</td><td>Don't cache 'har' filesystem instances.</td></tr><tr><td>hadoop.security.kms.client.authentication.retry-count</td><td>1</td><td>Number of time to retry connecting to KMS on authentication failure</td></tr><tr><td>hadoop.security.kms.client.encrypted.key.cache.size</td><td>500</td><td>Size of the EncryptedKeyVersion cache Queue for each key</td></tr><tr><td>hadoop.security.kms.client.encrypted.key.cache.low-watermark</td><td>0.3f</td><td>If size of the EncryptedKeyVersion cache Queue falls below the low watermark, this cache queue will be scheduled for a refill</td></tr><tr><td>hadoop.security.kms.client.encrypted.key.cache.num.refill.threads</td><td>2</td><td>Number of threads to use for refilling depleted EncryptedKeyVersion cache Queues</td></tr><tr><td>hadoop.security.kms.client.encrypted.key.cache.expiry</td><td>43200000</td><td>Cache expiry time for a Key, after which the cache Queue for this key will be dropped. Default = 12hrs</td></tr><tr><td>hadoop.security.sensitive-config-keys</td><td>password$,fs.s3.<em>[Ss]ecret.?[Kk]ey,fs.azure.account.key.</em>,dfs.webhdfs.oauth2.[a-z]+.token,hadoop.security.sensitive-config-keys</td><td>A comma-separated list of regular expressions to match against configuration keys that should be redacted where appropriate, for example, when logging modified properties during a reconfiguration, private credentials should not be logged.</td></tr></tbody></table><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>A-Za-z_ <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>_.A-Za-z0-9 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2020-12-09 17:43:54" itemprop="dateModified" datetime="2020-12-09T17:43:54+08:00">2020-12-09</time> </span><span id="2020/12/09/Platform-construction/Hadoop/course-2/hadoop配置详解/" class="item leancloud_visitors" data-flag-title="hadoop配置详解" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Andrésen 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Andrésen 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Andrésen 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Andrésen <i class="ic i-at"><em>@</em></i>Andrésen</li><li class="link"><strong>本文链接：</strong> <a href="https://methiony.work/2020/12/09/Platform-construction/Hadoop/course-2/hadoop%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/" title="hadoop配置详解">https://methiony.work/2020/12/09/Platform-construction/Hadoop/course-2/hadoop配置详解/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2020/12/04/Platform-construction/Hadoop/course-2/Hadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclga70tsj20zk0m84mr.jpg" title="Hadoop集群的文件配置参数"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Hadoop基础知识</span><h3>Hadoop集群的文件配置参数</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%BB%86%E8%8A%82"><span class="toc-number">1.</span> <span class="toc-text">配置细节</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2020/11/21/Platform-construction/Hadoop/course-2/Hadoop%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" rel="bookmark" title="Hadoop分布式集群搭建">Hadoop分布式集群搭建</a></li><li><a href="/2020/11/24/Platform-construction/Hadoop/course-2/Hadoop%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/" rel="bookmark" title="Hadoop基本介绍及相关知识">Hadoop基本介绍及相关知识</a></li><li><a href="/2020/11/25/Platform-construction/Hadoop/course-2/HDFS%E7%9A%84%E6%96%87%E4%BB%B6%E5%8F%8A%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/" rel="bookmark" title="HDFS的文件及元数据管理">HDFS的文件及元数据管理</a></li><li><a href="/2020/11/25/Platform-construction/Hadoop/course-2/HDFS%E7%9A%84API%E6%93%8D%E4%BD%9C/" rel="bookmark" title="HDFS的API操作">HDFS的API操作</a></li><li><a href="/2020/11/26/Platform-construction/Hadoop/course-2/Hadoop%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" rel="bookmark" title="Hadoop高可用集群搭建">Hadoop高可用集群搭建</a></li><li><a href="/2020/12/04/Platform-construction/Hadoop/course-2/Hdaoop%E7%9A%84%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" rel="bookmark" title="Hdaoop的伪分布式集群搭建">Hdaoop的伪分布式集群搭建</a></li><li><a href="/2020/12/04/Platform-construction/Hadoop/course-2/Hadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/" rel="bookmark" title="Hadoop集群的文件配置参数">Hadoop集群的文件配置参数</a></li><li class="active"><a href="/2020/12/09/Platform-construction/Hadoop/course-2/hadoop%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/" rel="bookmark" title="hadoop配置详解">hadoop配置详解</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Andrésen" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Andrésen</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">27</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FkbWluaW1hc3RlcnF3" title="https:&#x2F;&#x2F;github.com&#x2F;adminimasterqw"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9xdWFuLXdlaS0zNy05" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;quan-wei-37-9"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTQ4ODg0NDc5NQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;488844795"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20vNTgzMzM1MjYxMy9wcm9maWxlP3JpZ2h0bW9kPTEmd3ZyPTYmbW9kPXBlcnNvbmluZm8maXNfYWxsPTE=" title="https:&#x2F;&#x2F;weibo.com&#x2F;5833352613&#x2F;profile?rightmod&#x3D;1&amp;wvr&#x3D;6&amp;mod&#x3D;personinfo&amp;is_all&#x3D;1"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS93ZWkucXVhbg==" title="https:&#x2F;&#x2F;about.me&#x2F;wei.quan"><i class="ic i-address-card"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjEwMTE2NDQ2OTdAcXEuY29t" title="mailto:1011644697@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>链接</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Platform-construction/" title="分类于 大数据平台搭建">大数据平台搭建</a> <i class="ic i-angle-right"></i> <a href="/categories/Platform-construction/Zookeeper/" title="分类于 Zookeeper">Zookeeper</a> <i class="ic i-angle-right"></i> <a href="/categories/Platform-construction/Zookeeper/course-1/" title="分类于 Zookeeper基础知识">Zookeeper基础知识</a></div><span><a href="/2020/11/23/Platform-construction/Zookeeper/course-1/Zookeeper%E7%9A%84API%E6%93%8D%E4%BD%9C/" title="Zookeeper的API操作">Zookeeper的API操作</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Platform-construction/" title="分类于 大数据平台搭建">大数据平台搭建</a> <i class="ic i-angle-right"></i> <a href="/categories/Platform-construction/Hive/" title="分类于 Hive">Hive</a> <i class="ic i-angle-right"></i> <a href="/categories/Platform-construction/Hive/course-5/" title="分类于 Hive基础知识">Hive基础知识</a></div><span><a href="/2020/12/04/Platform-construction/Hive/course-5/Hive%E7%9A%84%E5%87%BD%E6%95%B0/" title="Hive的函数">Hive的函数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Platform-construction/" title="分类于 大数据平台搭建">大数据平台搭建</a> <i class="ic i-angle-right"></i> <a href="/categories/Platform-construction/Hive/" title="分类于 Hive">Hive</a> <i class="ic i-angle-right"></i> <a href="/categories/Platform-construction/Hive/course-5/" title="分类于 Hive基础知识">Hive基础知识</a></div><span><a href="/2020/12/04/Platform-construction/Hive/course-5/Hive-Shell%E5%8F%82%E6%95%B0/" title="Hive Shell参数">Hive Shell参数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Platform-construction/" title="分类于 大数据平台搭建">大数据平台搭建</a> <i class="ic i-angle-right"></i> <a href="/categories/Platform-construction/Zookeeper/" title="分类于 Zookeeper">Zookeeper</a> <i class="ic i-angle-right"></i> <a href="/categories/Platform-construction/Zookeeper/course-1/" title="分类于 Zookeeper基础知识">Zookeeper基础知识</a></div><span><a href="/2020/11/23/Platform-construction/Zookeeper/course-1/Zookeeper%E7%9A%84watch%E6%9C%BA%E5%88%B6/" title="Zookeeper的watch和选举机制">Zookeeper的watch和选举机制</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Platform-construction/" title="分类于 大数据平台搭建">大数据平台搭建</a> <i class="ic i-angle-right"></i> <a href="/categories/Platform-construction/Hadoop/" title="分类于 Hadoop">Hadoop</a> <i class="ic i-angle-right"></i> <a href="/categories/Platform-construction/Hadoop/course-2/" title="分类于 Hadoop基础知识">Hadoop基础知识</a></div><span><a href="/2020/11/25/Platform-construction/Hadoop/course-2/HDFS%E7%9A%84%E6%96%87%E4%BB%B6%E5%8F%8A%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/" title="HDFS的文件及元数据管理">HDFS的文件及元数据管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Platform-construction/" title="分类于 大数据平台搭建">大数据平台搭建</a> <i class="ic i-angle-right"></i> <a href="/categories/Platform-construction/MySQL/" title="分类于 MySQL">MySQL</a> <i class="ic i-angle-right"></i> <a href="/categories/Platform-construction/MySQL/course-6/" title="分类于 MySQL基础知识">MySQL基础知识</a></div><span><a href="/2020/11/28/Platform-construction/MySQL/course-6/Centos7%E4%B8%8BLinux%E7%B3%BB%E7%BB%9FMySQL%E5%AE%89%E8%A3%85/" title="Centos7下Linux系统MySQL安装">Centos7下Linux系统MySQL安装</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Platform-construction/" title="分类于 大数据平台搭建">大数据平台搭建</a> <i class="ic i-angle-right"></i> <a href="/categories/Platform-construction/Hadoop/" title="分类于 Hadoop">Hadoop</a> <i class="ic i-angle-right"></i> <a href="/categories/Platform-construction/Hadoop/course-2/" title="分类于 Hadoop基础知识">Hadoop基础知识</a></div><span><a href="/2020/12/09/Platform-construction/Hadoop/course-2/hadoop%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/" title="hadoop配置详解">hadoop配置详解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Platform-construction/" title="分类于 大数据平台搭建">大数据平台搭建</a> <i class="ic i-angle-right"></i> <a href="/categories/Platform-construction/Hive/" title="分类于 Hive">Hive</a> <i class="ic i-angle-right"></i> <a href="/categories/Platform-construction/Hive/course-5/" title="分类于 Hive基础知识">Hive基础知识</a></div><span><a href="/2020/12/04/Platform-construction/Hive/course-5/Hive%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/" title="Hive的数据压缩">Hive的数据压缩</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Platform-construction/" title="分类于 大数据平台搭建">大数据平台搭建</a> <i class="ic i-angle-right"></i> <a href="/categories/Platform-construction/Hadoop/" title="分类于 Hadoop">Hadoop</a> <i class="ic i-angle-right"></i> <a href="/categories/Platform-construction/Hadoop/course-2/" title="分类于 Hadoop基础知识">Hadoop基础知识</a></div><span><a href="/2020/11/24/Platform-construction/Hadoop/course-2/Hadoop%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/" title="Hadoop基本介绍及相关知识">Hadoop基本介绍及相关知识</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2020/11/15/MySQL/" title="MySQL">MySQL</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Andrésen @ Methiony Shoka</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">230k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">3:29</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2020/12/09/Platform-construction/Hadoop/course-2/hadoop配置详解/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.4"></script></body></html><!-- rebuild by hrmmi -->