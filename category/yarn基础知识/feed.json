{
    "version": "https://jsonfeed.org/version/1",
    "title": "Andrésen • All posts by \"yarn基础知识\" category",
    "description": "",
    "home_page_url": "https://methiony.work",
    "items": [
        {
            "id": "https://methiony.work/2020/11/28/Hadoop/Yarn/course-4/Yarn%E7%9A%84%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/",
            "url": "https://methiony.work/2020/11/28/Hadoop/Yarn/course-4/Yarn%E7%9A%84%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/",
            "title": "Yarn的参数设置",
            "date_published": "2020-11-28T02:20:28.000Z",
            "content_html": "<h1 id=\"1-yarn的调度器\"><a class=\"anchor\" href=\"#1-yarn的调度器\">#</a> 1、yarn 的调度器</h1>\n<p>yarn 我们都知道主要是用于做资源调度，任务分配等功能的，hadoop 支持好几种任务的调度方式，不同的场景需要使用不同的任务调度器.</p>\n<h2 id=\"fif0-scheduler队列调度\"><a class=\"anchor\" href=\"#fif0-scheduler队列调度\">#</a> FIF0 Scheduler (队列调度)</h2>\n<p>把任务按提交的顺序排成一个队列，这是一个先进先出队列，在进行资源分配的时候，先给队列中最头上的任务进行分配资源，待最头上任务需求满足后再给下一个分配，以此类推</p>\n<p>FIFO Scheduler 是最简单也是最容易理解的调度器，也不需要任何配置，但它并不适用于共享集群。大的任务可能会占用所有集群资源，这就导致其它任务被阻塞</p>\n<h2 id=\"capacity-scheduler容量调度器-apache版本默认使用的调度器\"><a class=\"anchor\" href=\"#capacity-scheduler容量调度器-apache版本默认使用的调度器\">#</a> Capacity Scheduler (容量调度器，apache 版本默认使用的调度器)</h2>\n<p>Capacity 调度器允许多个组织共享整个集群，每个组织可以获得集群的部分计算能力。通过为每个组织分配专门的队列，然后再为毎个队列分配一定的集群资源，这样整个集群就可以通过设置多个队列的方式给多个组织提供服务了。</p>\n<p>除此之外，对列内部又可以垂直划分，这样一个组织内部的多个成员就可以共享这个队列资源了，在一个队列内部，资源的调度是采用的是先进先出 (FIFO) 策略。</p>\n<h2 id=\"fair-scheduler公平调度器cdh版本的-hadoop默认使用的调度器\"><a class=\"anchor\" href=\"#fair-scheduler公平调度器cdh版本的-hadoop默认使用的调度器\">#</a> Fair Scheduler (公平调度器，CDH 版本的 hadoop 默认使用的调度器)</h2>\n<p>Fair 调度器的设计目标是为所有的应用分配公平的资源 (对公平的定义可以通过参数来设置)。公平调度在也可以在多个队列间工作。</p>\n<p>举个例子，假设有两个用户 A 和 B, 他们分别拥有一个队列。当 A 启动一个 job 而 B 没有任务时，A 会获得全部集群资源；当 B 启动一个 job 后，A 的 job 会继续运行，不过一会儿之后两个任务会各自获得一半的集群资源。如果此时 B 再启动第二个 job 并且其它 job 还在运行，则它将会和 B 的第一个 job 共享 B 这个队列的资源，也就是 B 的两个 job 会用于四分之一的集群资源，而 A 的 job 仍然用于集群一半的资源，结果就是资源最终在两个用户之间平等的共享</p>\n<h1 id=\"2-yarn常用参数设置\"><a class=\"anchor\" href=\"#2-yarn常用参数设置\">#</a> 2、yarn 常用参数设置</h1>\n<h2 id=\"设置-container分配最小内存\"><a class=\"anchor\" href=\"#设置-container分配最小内存\">#</a> 设置 container 分配最小内存</h2>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yarn.scheduler.minimum-allocation-mb 1024</pre></td></tr></table></figure><p>给应用程序 container 分配的最小内存</p>\n<h2 id=\"设置-container分配最大内存\"><a class=\"anchor\" href=\"#设置-container分配最大内存\">#</a> 设置 container 分配最大内存</h2>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yarn.scheduler.maximum-allocation-mb 8192</pre></td></tr></table></figure><p>给应用程序 container 分配的最大内存</p>\n<h2 id=\"设置每个-container的最小虚拟内核个数\"><a class=\"anchor\" href=\"#设置每个-container的最小虚拟内核个数\">#</a> 设置每个 container 的最小虚拟内核个数</h2>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yarn.scheduler.minimum-allocation-vcores 1</pre></td></tr></table></figure><p>每个 container 默认给分配的最小的虚拟内核个数</p>\n<h2 id=\"设置每个-container的最大虚拟内核个数\"><a class=\"anchor\" href=\"#设置每个-container的最大虚拟内核个数\">#</a> 设置每个 container 的最大虚拟内核个数</h2>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yarn.scheduler.maximum-allocation-vcores 32</pre></td></tr></table></figure><p>每个 container 可以分配的最大的虚拟内核的个数</p>\n<h2 id=\"设置-nodemanager可以分配的内存大小\"><a class=\"anchor\" href=\"#设置-nodemanager可以分配的内存大小\">#</a> 设置 NodeManager 可以分配的内存大小</h2>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yarn.nodemanager.resource.memory-mb 8192 nodemanager</pre></td></tr></table></figure><p>可以分配的最大内存大小，默认 8192Mb</p>\n<h2 id=\"定义每台机器的内存使用大小\"><a class=\"anchor\" href=\"#定义每台机器的内存使用大小\">#</a> 定义每台机器的内存使用大小</h2>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yarn.nodemanager.resource.memory-mb 8192</pre></td></tr></table></figure><h2 id=\"定义交换区空间可以使用的大小\"><a class=\"anchor\" href=\"#定义交换区空间可以使用的大小\">#</a> 定义交换区空间可以使用的大小</h2>\n<p>交换区空间就是讲一块硬盘拿出来做内存使用这里指定的是 nodemanager 的 2.1 倍</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yarn.nodemanager.vmem-pmem-ratio 2.1</pre></td></tr></table></figure>",
            "tags": []
        },
        {
            "id": "https://methiony.work/2020/11/27/Hadoop/Yarn/course-4/Yarn%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0/",
            "url": "https://methiony.work/2020/11/27/Hadoop/Yarn/course-4/Yarn%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0/",
            "title": "Yarn的基本概述",
            "date_published": "2020-11-27T13:56:16.000Z",
            "content_html": "<h1 id=\"1-yarn的介绍\"><a class=\"anchor\" href=\"#1-yarn的介绍\">#</a> 1、yarn 的介绍</h1>\n<p>yarn 是 hadoop 集群当中的资源管理系统模块，从 hadoop2.0 始引入 yarn 模块 yarn 可为各类计算框架提供资源的管理和调度，主要用于管理集群当中的资源 (主要是服务器的各种硬件资源，包括 CPU, 内存，磁盘，网络 1o 等) 以及调度运行在 yarn 上面的各种任务</p>\n<p>yarn 核心出发点是为了分离资源管理与作业监控，实现分离的做法是拥有一个全局的资源管理 (ResourceManager,RM), 以及每个应用程序对应一个的应用管理器 (Application Master, AM)</p>\n<p>yam 主要就是为了调度资源，管理任务等<br />\n其调度分为两个层级来说:<br />\n 一级调度管理<br />\n计算资源管理 (CPU, 内存，网络 IO, 磁盘)<br />\n 二级调度管理<br />\n任务内部的计算模型管理 (AppMaster 的任务精细化管理)</p>\n<h1 id=\"2-yarn的主要组件介绍与作用\"><a class=\"anchor\" href=\"#2-yarn的主要组件介绍与作用\">#</a> 2、Yarn 的主要组件介绍与作用</h1>\n<p>YARN 总体上是 Master/ Slave 结构，主要由 ResourceManager、NodeManager、Application Master 和 Container 等几个组件构成</p>\n<h2 id=\"1-resource-managerrm\"><a class=\"anchor\" href=\"#1-resource-managerrm\">#</a> 1、Resource Manager(RM)</h2>\n<p>负责处理客户端请求对各 NM 上的资源进行统一管理和调度。给 Application Master 分配空闲的 Container 运行并监控其运行状态。主要由两个组件构成：调度器和应用程序管理器</p>\n<h3 id=\"调度器scheduler\"><a class=\"anchor\" href=\"#调度器scheduler\">#</a> 调度器（scheduler）</h3>\n<p>调度器根据容量、队列等限制条件，将系统中的资源分配给各个正在运行的应用程序。调度器仅根据各个应用程序的资源需求进行资源分配，而资源分配单位是 Container。 Scheduler. 不负责监控或者跟踪应用程序的状态。总之，调度器根据应用程序的资源要求，以及集群机器的资源情况，为应用程序分配封装在 Container 中的资源</p>\n<h3 id=\"应用程序管理器-applications-manager\"><a class=\"anchor\" href=\"#应用程序管理器-applications-manager\">#</a> 应用程序管理器 (Applications Manager)</h3>\n<p>应用程序管理器负责管理整个系统中所有应用程序，包括应用程序提交、与调度器协商资源以启动 Application Master、监控 Application Master, 运行状态并在失败时重新启动等，跟踪分给的 Container 的进度、状态也是其职责。</p>\n<h2 id=\"2-nodemanagernm\"><a class=\"anchor\" href=\"#2-nodemanagernm\">#</a> 2、NodeManager(NM)</h2>\n<p>NodeManager 是每个节点上的资源和任务管理器。它会定时地向 ResourceManager 汇报本节点上的资源使用情况和各个 Container 的运行状态；同时会接收并处理来自 ApplicationMaster 的 Container 启动停止等请求。</p>\n<h2 id=\"3-applicationmasteram\"><a class=\"anchor\" href=\"#3-applicationmasteram\">#</a> 3、ApplicationMaster(AM)</h2>\n<p>用户提交的应用程序均包含一个 Application Master, 负责应用的监控，跟踪应用执行状态，重启失败任务等。 Application Master 是应用框架，它负责向 ResourceManager 协调资源，并且与 Node Manager 协同工作完成 Task 的执行和监控</p>\n<h2 id=\"4-container\"><a class=\"anchor\" href=\"#4-container\">#</a> 4、Container</h2>\n<p>Container 是 YARN 中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等，当 ApplicationMaster 向 ResourceManager 申请资源时，ResourceManager 为 ApplicationMaster 返回的资源便是用 Container 表示的。</p>\n",
            "tags": []
        }
    ]
}